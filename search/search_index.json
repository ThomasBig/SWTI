{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to SWTI Docs 1.4 Simple Windows Text Interface is made out of 4 static objects. Cursor which is used for printing colorful text on screen Keyboard which is used for detecting user keyboard input Mouse which is used for detecting user mouse input Window which is used for resizing window These four objects have in total about 40 methods to interact with console. Installation The installation of SWTI library is easy. Download repository and copy the folder SWTI/swti to your project folder. It contains header and source code for the library. In your application, include a header \"#include swti/swti.hpp\" . Visual Studio - you will also need to add header and source files to your project. Right click on the right folder header files and add existing file and choose SWTI/swti.hpp . Do the same for source files and add SWTI/swti.cpp . Code Blocks - click on the left pane folders and add existing header and source files to your project. GNU Console - You can use following command g++ main.cpp swti/swti.cpp -o main.exe to compile your project. Change main.cpp and main.exe to whatever you prefer. If you get some errors, make sure you are including the header and you can use these flags -static-libstdc++ -static-libgcc . Hello world You can use this simple example to ensure that SWTI library is installed correctly. Following code writes colorful Hello world on a specified position. It uses the Cursor object and methods setColor and setPosition. #include <iostream> #include \"swti/swti.hpp\" int main() { Cursor.setColor(YELLOW); Cursor.setPosition(5, 2); std::cout << \"Hello world!\" << std::endl; } Troubleshooting If something doesn't work, try to create a new project without any additional libraries other than SWTI. If you succeed, the problem is collision with function names in the library. In C++ functions or objects with same names cannot be used and namespace should be used. To solve this issue, you can create one for swti, in which you include a header and the source file. #include <iostream> namespace swti { #include \"swti/swti.hpp\" #include \"swti/swti.cpp\" // source is needed } int main() { swti::Color color = swti::LIGHTGREEN; swti::Cursor.setColor(color); std::cout << \"SWTI Works!\\n\"; } You need to use swti:: prefix for every function and object. If something still doesn't work, please add issue .","title":"Home"},{"location":"#welcome-to-swti-docs-14","text":"Simple Windows Text Interface is made out of 4 static objects. Cursor which is used for printing colorful text on screen Keyboard which is used for detecting user keyboard input Mouse which is used for detecting user mouse input Window which is used for resizing window These four objects have in total about 40 methods to interact with console.","title":"Welcome to SWTI Docs 1.4"},{"location":"#installation","text":"The installation of SWTI library is easy. Download repository and copy the folder SWTI/swti to your project folder. It contains header and source code for the library. In your application, include a header \"#include swti/swti.hpp\" . Visual Studio - you will also need to add header and source files to your project. Right click on the right folder header files and add existing file and choose SWTI/swti.hpp . Do the same for source files and add SWTI/swti.cpp . Code Blocks - click on the left pane folders and add existing header and source files to your project. GNU Console - You can use following command g++ main.cpp swti/swti.cpp -o main.exe to compile your project. Change main.cpp and main.exe to whatever you prefer. If you get some errors, make sure you are including the header and you can use these flags -static-libstdc++ -static-libgcc .","title":"Installation"},{"location":"#hello-world","text":"You can use this simple example to ensure that SWTI library is installed correctly. Following code writes colorful Hello world on a specified position. It uses the Cursor object and methods setColor and setPosition. #include <iostream> #include \"swti/swti.hpp\" int main() { Cursor.setColor(YELLOW); Cursor.setPosition(5, 2); std::cout << \"Hello world!\" << std::endl; }","title":"Hello world"},{"location":"#troubleshooting","text":"If something doesn't work, try to create a new project without any additional libraries other than SWTI. If you succeed, the problem is collision with function names in the library. In C++ functions or objects with same names cannot be used and namespace should be used. To solve this issue, you can create one for swti, in which you include a header and the source file. #include <iostream> namespace swti { #include \"swti/swti.hpp\" #include \"swti/swti.cpp\" // source is needed } int main() { swti::Color color = swti::LIGHTGREEN; swti::Cursor.setColor(color); std::cout << \"SWTI Works!\\n\"; } You need to use swti:: prefix for every function and object. If something still doesn't work, please add issue .","title":"Troubleshooting"},{"location":"about/","text":"About Contributing You can improve the library by contributing to it. If you find a bug, please write it in issues . You can also write a code for a new useful function and add a merge request . Keep in mind the function has to be usable in any applications or game. Excluding too specific functions make library simple to learn and easy to use. Credits This library is currently maintained by one person. Feel free to contribute . License The library is licensed under MIT License . You can use the code in any application, but without warranty. That means you can make any application with the library but I am not responsible for any crashes and further problems.","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#contributing","text":"You can improve the library by contributing to it. If you find a bug, please write it in issues . You can also write a code for a new useful function and add a merge request . Keep in mind the function has to be usable in any applications or game. Excluding too specific functions make library simple to learn and easy to use.","title":"Contributing"},{"location":"about/#credits","text":"This library is currently maintained by one person. Feel free to contribute .","title":"Credits"},{"location":"about/#license","text":"The library is licensed under MIT License . You can use the code in any application, but without warranty. That means you can make any application with the library but I am not responsible for any crashes and further problems.","title":"License"},{"location":"examples/arcade/","text":"Arcade game Let's create arcade game shall we? I want to create game where player needs to find a treasure before enemies kill him. Levels will be randomly generated. Enemies will slowly hunt the player. Wall class I will start with general class Object. Object has position, character and color. I will protect attributes, because later I want to inherit this class. I will add three constructors, one with full customization, second that creates gray wall and third that will create wall on 0, 0 position. I will also add methods show and hide for displaying the object in window. Lastly I added simple collision function that takes position and returns true if given position matches with object position. class Object { protected: int x, y; char skin; Color color; public: Object(int xpos, int ypos, char type, Color col) : x(xpos), y(ypos), skin(type), color(col) { show(); } Object(int xpos, int ypos) : Object(xpos, ypos, (char) FILL_F, GRAY) { } Object() : Object(0, 0) { } int getX() { return x; } int getY() { return y; } void show() { Cursor.printChar(x, y, skin, color); } void hide() { Cursor.printBlank(x, y); } bool collision(int xt, int yt) { return x == xt && y == yt; } }; To check collision with more objects I will create wallCollision function that takes a vector of walls (dynamic array). I need to go through all walls from vector and check the collision. There are two ways how to solve the problem. // Iterative solution bool wallCollision(int x, int y, std::vector<Object*>& walls) { for(auto wall: walls) if (wall -> collision(x, y)) return true; return false; } // Functional solution (requires algorithms library) bool wallCollision(int x, int y, std::vector<Object*>& walls) { return std::any_of(walls.begin(), walls.end(), [&](auto& wall) { return wall -> collision(x, y); }); } Now I will use this object to populate level with random walls. I will create border of size 18 and 100 random walls inside. Roughly 30% of the level will be walls. In main I will set window size and font size. I will set width and height of font to one value so that font character will fit in square. To have different levels each game, I can use srand and library time.h to set random seed. void create_walls(std::vector<Object*>& walls) { int posx, posy; for (int i = 0; i < 18; i++) { walls.push_back(new Object(i,0)); walls.push_back(new Object(i+1,18)); walls.push_back(new Object(0,i+1)); walls.push_back(new Object(18,i)); } for (int i = 0; i < 100; i++) { posx = 2 + rand() % 15; posy = 2 + rand() % 15; if (posx != 1 && posy != 1 && !wallCollision(posx, posy, walls)) { walls.push_back(new Object(posx, posy)); } } } int main() { int fontSize = Window.getScreenHeight() / 36; Cursor.setFontPixels(fontSize, fontSize); Window.setSizeChars(20, 20); srand((int)time(NULL)); std::vector<Object*> walls; create_walls(walls); Keyboard.waitUser(); return 0; } Player class We have walls, now we need to add player. To create class Player I will inherit class Object and make move method. When I press 'W' button, I first check if there is a collision and only if there is none I move the player. In main I will add loop that will control the player and Keyboard.wait to slow fast input checks. class Player : public Object { public: Player(int px, int py) : Object(px, py, '*', LIGHTGREEN) { } Player() : Player (1, 1) { } void move(std::vector<Object*>& walls) { int nx = x, ny = y; if (Keyboard.get('W') && !wallCollision(x, y-1, walls)) { ny--; } if (Keyboard.get('S') && !wallCollision(x, y+1, walls)) { ny++; } if (Keyboard.get('A') && !wallCollision(x-1, y, walls)) { nx--; } if (Keyboard.get('D') && !wallCollision(x+1, y, walls)) { nx++; } if ((nx != x || ny != y) && !wallCollision(nx, ny, walls)) { hide(); x = nx; y = ny; show(); } } }; int main() { int fontSize = Window.getScreenHeight() / 36; Cursor.setFontPixels(fontSize, fontSize); Window.setSizeChars(20, 20); Window.hideBlinking(); std::vector<Object*> walls; create_walls(walls); Player *player = new Player(1,1); while(!Keyboard.get(VK_ESCAPE)) { player->move(walls); Keyboard.wait(30); } return 0; } In this gif there can be seen jagged walls, I am not 100% of the cause but I suspect different font would solve the issue. This code is run from my IDE but if I run code directly from folder, there are no jagged lines. Enemy class In the similar way as I created player I will create enemy. I will change color to red and symbol to X. For move function I will need position of player. Enemies will be quiet dumb, if player is above them they will try to move up, if player is to their left, they will move left. They will also respect wall collisions. I will add create_enemies function that spawns enemies at random positions. Lastly I will add loop that loops through all enemies and slowly moves them towards player. class Enemy : public Object { public: Enemy(int px, int py) : Object(px, py, (char) 158, LIGHTRED) { cooldown = 0; } Enemy() : Enemy (1, 1) { } void move(Player* player, std::vector<Object*>& walls) { int nx = x, ny = y; if (y > player->getY() && !wallCollision(x, y-1, walls)) { ny--; } else if (y < player->getY() && !wallCollision(x, y+1, walls)) { ny++; } else if (x > player->getX() && !wallCollision(x-1, y, walls)) { nx--; } else if (x < player->getX() && !wallCollision(x+1, y, walls)) { nx++; } if ((nx != x || ny != y) && !wallCollision(nx, ny, walls)) { hide(); x = nx; y = ny; show(); } } }; void create_enemies(std::vector<Enemy*>& enemies, std::vector<Object*>& walls) { int posx, posy; for (int i = 0; i < 1 + rand() % 3; i++) { do { posx = 2 + rand() % 15; posy = 2 + rand() % 15; } while (wallCollision(posx, posy, walls)); enemies.push_back(new Enemy(posx, posy)); } } int main() { int fontSize = Window.getScreenHeight() / 36; Cursor.setFontPixels(fontSize, fontSize); Window.setSizeChars(20, 20); Window.hideBlinking(); std::vector<Object*> walls; std::vector<Enemy*> enemies; create_walls(walls); create_enemies(enemies, walls); Player *player = new Player(1,1); int cooldown = 0; while(!Keyboard.get(VK_ESCAPE)) { player->move(walls); for(auto& enemy: enemies) { if (cooldown > 1) { enemy->move(player, walls); } if (enemy -> collision(player -> getX(), player -> getY())) { std::cout << \"You are dead!\"; goto END; } } if (cooldown++ > 1) { cooldown = 0; } Keyboard.wait(30); } END: walls.clear(); enemies.clear(); return 0; } Treasure Treasure is simple object, could be new class but it is not really necessary. If player collides with treasure, he wins the game. When moving with enemy if I detect collision with treasure, I repaint the treasure (otherwise treasure would remain hidden once enemy moves over it). Choosing treasure position is done simply, however in rare situations treasure will be stuck inside walls and player will be unable to reach it. To solve this I would use path search algorithm, but it is outside the scope of this tutorial. void Enemy::move(Player* player, Object* treasure, std::vector<Object*>& walls) { int nx = x, ny = y; // redraw enemy only if neccessary if (y > player->getY() && !wallCollision(x, y-1, walls)) { ny--; } else if (y < player->getY() && !wallCollision(x, y+1, walls)) { ny++; } else if (x > player->getX() && !wallCollision(x-1, y, walls)) { nx--; } else if (x < player->getX() && !wallCollision(x+1, y, walls)) { nx++; } if ((nx != x || ny != y) && !wallCollision(nx, ny, walls)) { if (!treasure->collision(x, y)) { hide(); } else { treasure->show(); } x = nx; y = ny; show(); } } Object* create_treasure(std::vector<Object*>& walls) { int posx, posy; do { posx = 8 + rand() % 5; posy = 8 + rand() % 5; } while (wallCollision(posx, posy, walls)); return new Object(posx, posy, 'o', LIGHTYELLOW); } int main() { ... Object* treasure = create_treasure(walls); while(!Keyboard.get(VK_ESCAPE)) { player->move(walls); if (treasure -> collision(player -> getX(), player -> getY())) { std::cout << \"You got treasure\"; goto END; } ... } ... } Easier main From the last two paragraphs it is obvious that main is too large. I will add two functions to make it easier to read. Game function will control one game instance and after player wins or dies it ends. Also I will add end function that will print fancy text and handle clearing of memory. void end(std::string text, Color col, Player *player, std::vector<Object*>& walls, std::vector<Enemy*>& enemies, Object* treasure) { player->show(); Cursor.setPosition(text.length() > 15 ? 1 : 3, 5); Cursor.setColor(col); std::cout << text; Keyboard.waitUser(); Cursor.clearScreen(); walls.clear(); enemies.clear(); delete player; delete treasure; } bool game() { ... } int main() { int fontSize = Window.getScreenHeight() / 36; Cursor.setFontPixels(fontSize, fontSize); Window.setSizeChars(20, 20); Window.hideResize(); Window.hideBlinking(); Window.hideScrollbars(); while(game()) { } return 0; } Full code Code for board game is following. On the github you can find similar code with more comments for this game. #include <iostream> #include <vector> #include <time.h> #include \"swti/swti.hpp\" class Object { protected: int x, y; char skin; Color color; public: Object(int xpos, int ypos, char type, Color col) : x(xpos), y(ypos), skin(type), color(col) { show(); } Object(int xpos, int ypos) : Object(xpos, ypos, (char) FILL_F, GRAY) { } Object() : Object(0, 0) { } void show() { Cursor.printChar(x, y, skin, color); } void hide() { Cursor.printBlank(x, y); } bool collision(int xt, int yt) { return x == xt && y == yt; } }; bool wallCollision(int x, int y, std::vector<Object*>& walls) { for(auto wall: walls) if (wall -> collision(x, y)) return true; return false; } void create_walls(std::vector<Object*>& walls) { int posx, posy; for (int i = 0; i < 18; i++) { walls.push_back(new Object(i,0)); walls.push_back(new Object(i+1,18)); walls.push_back(new Object(0,i+1)); walls.push_back(new Object(18,i)); } for (int i = 0; i < 100; i++) { posx = 2 + rand() % 15; posy = 2 + rand() % 15; if (posx != 1 && posy != 1 && !wallCollision(posx, posy, walls)) { walls.push_back(new Object(posx, posy)); } } } class Player : public Object { public: Player(int px, int py) : Object(px, py, '*', LIGHTGREEN) { } Player() : Player (1, 1) { } int getX() { return x; } int getY() { return y; } void move(std::vector<Object*>& walls) { int nx = x, ny = y; if (Keyboard.get('W') && !wallCollision(x, y-1, walls)) { ny--; } if (Keyboard.get('S') && !wallCollision(x, y+1, walls)) { ny++; } if (Keyboard.get('A') && !wallCollision(x-1, y, walls)) { nx--; } if (Keyboard.get('D') && !wallCollision(x+1, y, walls)) { nx++; } if ((nx != x || ny != y) && !wallCollision(nx, ny, walls)) { hide(); x = nx; y = ny; show(); } } }; class Enemy : public Object { public: Enemy(int px, int py) : Object(px, py, (char) 158, LIGHTRED) { } Enemy() : Enemy (1, 1) { } void move(Player* player, Object* treasure, std::vector<Object*>& walls) { int nx = x, ny = y; // redraw enemy only if neccessary if (y > player->getY() && !wallCollision(x, y-1, walls)) { ny--; } else if (y < player->getY() && !wallCollision(x, y+1, walls)) { ny++; } else if (x > player->getX() && !wallCollision(x-1, y, walls)) { nx--; } else if (x < player->getX() && !wallCollision(x+1, y, walls)) { nx++; } if ((nx != x || ny != y) && !wallCollision(nx, ny, walls)) { if (!treasure->collision(x, y)) { hide(); } else { treasure->show(); } x = nx; y = ny; show(); } } }; void create_enemies(std::vector<Enemy*>& enemies, std::vector<Object*>& walls) { int posx, posy; for (int i = 0; i < 1 + rand() % 3; i++) { do { posx = 2 + rand() % 15; posy = 2 + rand() % 15; } while (wallCollision(posx, posy, walls)); enemies.push_back(new Enemy(posx, posy)); } } Object* create_treasure(std::vector<Object*>& walls) { int posx, posy; do { posx = 8 + rand() % 5; posy = 8 + rand() % 5; } while (wallCollision(posx, posy, walls)); return new Object(posx, posy, 'o', LIGHTYELLOW); } void end(std::string text, Color col, Player *player, std::vector<Object*>& walls, std::vector<Enemy*>& enemies, Object* treasure) { player->show(); Cursor.setPosition(text.length() > 15 ? 1 : 3, 5); Cursor.setColor(col); std::cout << text; Keyboard.waitUser(); Cursor.clearScreen(); walls.clear(); enemies.clear(); delete player; delete treasure; } bool game() { Player *player = new Player(1,1); std::vector<Object*> walls; std::vector<Enemy*> enemies; int cooldown = 0; srand((int)time(NULL)); create_walls(walls); create_enemies(enemies, walls); Object* treasure = create_treasure(walls); Keyboard.waitUser(); while(!Keyboard.get(VK_ESCAPE)) { player -> move(walls); if (treasure -> collision(player -> getX(), player -> getY())) { end(\"You got treasure!\", LIGHTYELLOW, player, walls, enemies, treasure); return true; } for(auto& enemy: enemies) { if (cooldown > 1) { enemy -> move(player, treasure, walls); } if (enemy -> collision(player -> getX(), player -> getY())) { end(\"You are dead!\", LIGHTRED, player, walls, enemies, treasure); return true; } } if (cooldown++ > 1) { cooldown = 0; } Keyboard.wait(30); } end(\"See you soon.\", LIGHTYELLOW, player, walls, enemies, treasure); return false; } int main() { int fontSize = Window.getScreenHeight() / 36; Cursor.setFontPixels(fontSize, fontSize); Window.setSizeChars(20, 20); Window.hideResize(); Window.hideBlinking(); Window.hideScrollbars(); while(game()) { } return 0; }","title":"Arcade game"},{"location":"examples/arcade/#arcade-game","text":"Let's create arcade game shall we? I want to create game where player needs to find a treasure before enemies kill him. Levels will be randomly generated. Enemies will slowly hunt the player.","title":"Arcade game"},{"location":"examples/arcade/#wall-class","text":"I will start with general class Object. Object has position, character and color. I will protect attributes, because later I want to inherit this class. I will add three constructors, one with full customization, second that creates gray wall and third that will create wall on 0, 0 position. I will also add methods show and hide for displaying the object in window. Lastly I added simple collision function that takes position and returns true if given position matches with object position. class Object { protected: int x, y; char skin; Color color; public: Object(int xpos, int ypos, char type, Color col) : x(xpos), y(ypos), skin(type), color(col) { show(); } Object(int xpos, int ypos) : Object(xpos, ypos, (char) FILL_F, GRAY) { } Object() : Object(0, 0) { } int getX() { return x; } int getY() { return y; } void show() { Cursor.printChar(x, y, skin, color); } void hide() { Cursor.printBlank(x, y); } bool collision(int xt, int yt) { return x == xt && y == yt; } }; To check collision with more objects I will create wallCollision function that takes a vector of walls (dynamic array). I need to go through all walls from vector and check the collision. There are two ways how to solve the problem. // Iterative solution bool wallCollision(int x, int y, std::vector<Object*>& walls) { for(auto wall: walls) if (wall -> collision(x, y)) return true; return false; } // Functional solution (requires algorithms library) bool wallCollision(int x, int y, std::vector<Object*>& walls) { return std::any_of(walls.begin(), walls.end(), [&](auto& wall) { return wall -> collision(x, y); }); } Now I will use this object to populate level with random walls. I will create border of size 18 and 100 random walls inside. Roughly 30% of the level will be walls. In main I will set window size and font size. I will set width and height of font to one value so that font character will fit in square. To have different levels each game, I can use srand and library time.h to set random seed. void create_walls(std::vector<Object*>& walls) { int posx, posy; for (int i = 0; i < 18; i++) { walls.push_back(new Object(i,0)); walls.push_back(new Object(i+1,18)); walls.push_back(new Object(0,i+1)); walls.push_back(new Object(18,i)); } for (int i = 0; i < 100; i++) { posx = 2 + rand() % 15; posy = 2 + rand() % 15; if (posx != 1 && posy != 1 && !wallCollision(posx, posy, walls)) { walls.push_back(new Object(posx, posy)); } } } int main() { int fontSize = Window.getScreenHeight() / 36; Cursor.setFontPixels(fontSize, fontSize); Window.setSizeChars(20, 20); srand((int)time(NULL)); std::vector<Object*> walls; create_walls(walls); Keyboard.waitUser(); return 0; }","title":"Wall class"},{"location":"examples/arcade/#player-class","text":"We have walls, now we need to add player. To create class Player I will inherit class Object and make move method. When I press 'W' button, I first check if there is a collision and only if there is none I move the player. In main I will add loop that will control the player and Keyboard.wait to slow fast input checks. class Player : public Object { public: Player(int px, int py) : Object(px, py, '*', LIGHTGREEN) { } Player() : Player (1, 1) { } void move(std::vector<Object*>& walls) { int nx = x, ny = y; if (Keyboard.get('W') && !wallCollision(x, y-1, walls)) { ny--; } if (Keyboard.get('S') && !wallCollision(x, y+1, walls)) { ny++; } if (Keyboard.get('A') && !wallCollision(x-1, y, walls)) { nx--; } if (Keyboard.get('D') && !wallCollision(x+1, y, walls)) { nx++; } if ((nx != x || ny != y) && !wallCollision(nx, ny, walls)) { hide(); x = nx; y = ny; show(); } } }; int main() { int fontSize = Window.getScreenHeight() / 36; Cursor.setFontPixels(fontSize, fontSize); Window.setSizeChars(20, 20); Window.hideBlinking(); std::vector<Object*> walls; create_walls(walls); Player *player = new Player(1,1); while(!Keyboard.get(VK_ESCAPE)) { player->move(walls); Keyboard.wait(30); } return 0; } In this gif there can be seen jagged walls, I am not 100% of the cause but I suspect different font would solve the issue. This code is run from my IDE but if I run code directly from folder, there are no jagged lines.","title":"Player class"},{"location":"examples/arcade/#enemy-class","text":"In the similar way as I created player I will create enemy. I will change color to red and symbol to X. For move function I will need position of player. Enemies will be quiet dumb, if player is above them they will try to move up, if player is to their left, they will move left. They will also respect wall collisions. I will add create_enemies function that spawns enemies at random positions. Lastly I will add loop that loops through all enemies and slowly moves them towards player. class Enemy : public Object { public: Enemy(int px, int py) : Object(px, py, (char) 158, LIGHTRED) { cooldown = 0; } Enemy() : Enemy (1, 1) { } void move(Player* player, std::vector<Object*>& walls) { int nx = x, ny = y; if (y > player->getY() && !wallCollision(x, y-1, walls)) { ny--; } else if (y < player->getY() && !wallCollision(x, y+1, walls)) { ny++; } else if (x > player->getX() && !wallCollision(x-1, y, walls)) { nx--; } else if (x < player->getX() && !wallCollision(x+1, y, walls)) { nx++; } if ((nx != x || ny != y) && !wallCollision(nx, ny, walls)) { hide(); x = nx; y = ny; show(); } } }; void create_enemies(std::vector<Enemy*>& enemies, std::vector<Object*>& walls) { int posx, posy; for (int i = 0; i < 1 + rand() % 3; i++) { do { posx = 2 + rand() % 15; posy = 2 + rand() % 15; } while (wallCollision(posx, posy, walls)); enemies.push_back(new Enemy(posx, posy)); } } int main() { int fontSize = Window.getScreenHeight() / 36; Cursor.setFontPixels(fontSize, fontSize); Window.setSizeChars(20, 20); Window.hideBlinking(); std::vector<Object*> walls; std::vector<Enemy*> enemies; create_walls(walls); create_enemies(enemies, walls); Player *player = new Player(1,1); int cooldown = 0; while(!Keyboard.get(VK_ESCAPE)) { player->move(walls); for(auto& enemy: enemies) { if (cooldown > 1) { enemy->move(player, walls); } if (enemy -> collision(player -> getX(), player -> getY())) { std::cout << \"You are dead!\"; goto END; } } if (cooldown++ > 1) { cooldown = 0; } Keyboard.wait(30); } END: walls.clear(); enemies.clear(); return 0; }","title":"Enemy class"},{"location":"examples/arcade/#treasure","text":"Treasure is simple object, could be new class but it is not really necessary. If player collides with treasure, he wins the game. When moving with enemy if I detect collision with treasure, I repaint the treasure (otherwise treasure would remain hidden once enemy moves over it). Choosing treasure position is done simply, however in rare situations treasure will be stuck inside walls and player will be unable to reach it. To solve this I would use path search algorithm, but it is outside the scope of this tutorial. void Enemy::move(Player* player, Object* treasure, std::vector<Object*>& walls) { int nx = x, ny = y; // redraw enemy only if neccessary if (y > player->getY() && !wallCollision(x, y-1, walls)) { ny--; } else if (y < player->getY() && !wallCollision(x, y+1, walls)) { ny++; } else if (x > player->getX() && !wallCollision(x-1, y, walls)) { nx--; } else if (x < player->getX() && !wallCollision(x+1, y, walls)) { nx++; } if ((nx != x || ny != y) && !wallCollision(nx, ny, walls)) { if (!treasure->collision(x, y)) { hide(); } else { treasure->show(); } x = nx; y = ny; show(); } } Object* create_treasure(std::vector<Object*>& walls) { int posx, posy; do { posx = 8 + rand() % 5; posy = 8 + rand() % 5; } while (wallCollision(posx, posy, walls)); return new Object(posx, posy, 'o', LIGHTYELLOW); } int main() { ... Object* treasure = create_treasure(walls); while(!Keyboard.get(VK_ESCAPE)) { player->move(walls); if (treasure -> collision(player -> getX(), player -> getY())) { std::cout << \"You got treasure\"; goto END; } ... } ... }","title":"Treasure"},{"location":"examples/arcade/#easier-main","text":"From the last two paragraphs it is obvious that main is too large. I will add two functions to make it easier to read. Game function will control one game instance and after player wins or dies it ends. Also I will add end function that will print fancy text and handle clearing of memory. void end(std::string text, Color col, Player *player, std::vector<Object*>& walls, std::vector<Enemy*>& enemies, Object* treasure) { player->show(); Cursor.setPosition(text.length() > 15 ? 1 : 3, 5); Cursor.setColor(col); std::cout << text; Keyboard.waitUser(); Cursor.clearScreen(); walls.clear(); enemies.clear(); delete player; delete treasure; } bool game() { ... } int main() { int fontSize = Window.getScreenHeight() / 36; Cursor.setFontPixels(fontSize, fontSize); Window.setSizeChars(20, 20); Window.hideResize(); Window.hideBlinking(); Window.hideScrollbars(); while(game()) { } return 0; }","title":"Easier main"},{"location":"examples/arcade/#full-code","text":"Code for board game is following. On the github you can find similar code with more comments for this game. #include <iostream> #include <vector> #include <time.h> #include \"swti/swti.hpp\" class Object { protected: int x, y; char skin; Color color; public: Object(int xpos, int ypos, char type, Color col) : x(xpos), y(ypos), skin(type), color(col) { show(); } Object(int xpos, int ypos) : Object(xpos, ypos, (char) FILL_F, GRAY) { } Object() : Object(0, 0) { } void show() { Cursor.printChar(x, y, skin, color); } void hide() { Cursor.printBlank(x, y); } bool collision(int xt, int yt) { return x == xt && y == yt; } }; bool wallCollision(int x, int y, std::vector<Object*>& walls) { for(auto wall: walls) if (wall -> collision(x, y)) return true; return false; } void create_walls(std::vector<Object*>& walls) { int posx, posy; for (int i = 0; i < 18; i++) { walls.push_back(new Object(i,0)); walls.push_back(new Object(i+1,18)); walls.push_back(new Object(0,i+1)); walls.push_back(new Object(18,i)); } for (int i = 0; i < 100; i++) { posx = 2 + rand() % 15; posy = 2 + rand() % 15; if (posx != 1 && posy != 1 && !wallCollision(posx, posy, walls)) { walls.push_back(new Object(posx, posy)); } } } class Player : public Object { public: Player(int px, int py) : Object(px, py, '*', LIGHTGREEN) { } Player() : Player (1, 1) { } int getX() { return x; } int getY() { return y; } void move(std::vector<Object*>& walls) { int nx = x, ny = y; if (Keyboard.get('W') && !wallCollision(x, y-1, walls)) { ny--; } if (Keyboard.get('S') && !wallCollision(x, y+1, walls)) { ny++; } if (Keyboard.get('A') && !wallCollision(x-1, y, walls)) { nx--; } if (Keyboard.get('D') && !wallCollision(x+1, y, walls)) { nx++; } if ((nx != x || ny != y) && !wallCollision(nx, ny, walls)) { hide(); x = nx; y = ny; show(); } } }; class Enemy : public Object { public: Enemy(int px, int py) : Object(px, py, (char) 158, LIGHTRED) { } Enemy() : Enemy (1, 1) { } void move(Player* player, Object* treasure, std::vector<Object*>& walls) { int nx = x, ny = y; // redraw enemy only if neccessary if (y > player->getY() && !wallCollision(x, y-1, walls)) { ny--; } else if (y < player->getY() && !wallCollision(x, y+1, walls)) { ny++; } else if (x > player->getX() && !wallCollision(x-1, y, walls)) { nx--; } else if (x < player->getX() && !wallCollision(x+1, y, walls)) { nx++; } if ((nx != x || ny != y) && !wallCollision(nx, ny, walls)) { if (!treasure->collision(x, y)) { hide(); } else { treasure->show(); } x = nx; y = ny; show(); } } }; void create_enemies(std::vector<Enemy*>& enemies, std::vector<Object*>& walls) { int posx, posy; for (int i = 0; i < 1 + rand() % 3; i++) { do { posx = 2 + rand() % 15; posy = 2 + rand() % 15; } while (wallCollision(posx, posy, walls)); enemies.push_back(new Enemy(posx, posy)); } } Object* create_treasure(std::vector<Object*>& walls) { int posx, posy; do { posx = 8 + rand() % 5; posy = 8 + rand() % 5; } while (wallCollision(posx, posy, walls)); return new Object(posx, posy, 'o', LIGHTYELLOW); } void end(std::string text, Color col, Player *player, std::vector<Object*>& walls, std::vector<Enemy*>& enemies, Object* treasure) { player->show(); Cursor.setPosition(text.length() > 15 ? 1 : 3, 5); Cursor.setColor(col); std::cout << text; Keyboard.waitUser(); Cursor.clearScreen(); walls.clear(); enemies.clear(); delete player; delete treasure; } bool game() { Player *player = new Player(1,1); std::vector<Object*> walls; std::vector<Enemy*> enemies; int cooldown = 0; srand((int)time(NULL)); create_walls(walls); create_enemies(enemies, walls); Object* treasure = create_treasure(walls); Keyboard.waitUser(); while(!Keyboard.get(VK_ESCAPE)) { player -> move(walls); if (treasure -> collision(player -> getX(), player -> getY())) { end(\"You got treasure!\", LIGHTYELLOW, player, walls, enemies, treasure); return true; } for(auto& enemy: enemies) { if (cooldown > 1) { enemy -> move(player, treasure, walls); } if (enemy -> collision(player -> getX(), player -> getY())) { end(\"You are dead!\", LIGHTRED, player, walls, enemies, treasure); return true; } } if (cooldown++ > 1) { cooldown = 0; } Keyboard.wait(30); } end(\"See you soon.\", LIGHTYELLOW, player, walls, enemies, treasure); return false; } int main() { int fontSize = Window.getScreenHeight() / 36; Cursor.setFontPixels(fontSize, fontSize); Window.setSizeChars(20, 20); Window.hideResize(); Window.hideBlinking(); Window.hideScrollbars(); while(game()) { } return 0; }","title":"Full code"},{"location":"examples/examples/","text":"Some examples Source examples.cpp includes miscellaneous functions that can be useful in variety games and applications. It includes simple board game and aligned text printing. Text aligment Let's start with the text. In order to differentiate various aligns, I will create two enums. One for horizontal align and second for vertical. enum HAlign { LEFT, CENTER, RIGHT }; enum VAlign { TOP, MIDDLE, DOWN }; My goal is to create function that takes position, string of text and align. I can calculate vertical align by counting number of new lines in text. That can be done using std::count from library. So far my function looks like this. It is missing horizontal align. void printText(int x, int y, std::string text, HAlign halign=LEFT, VAlign valign=TOP); { int xx = 0, yy = 0; int cnt = std::count(text.begin(), text.end(), '\\n'); switch (valign) { case TOP: yy = 0; break; case MIDDLE: yy = cnt / 2; break; case DOWN: yy = cnt; break; } Cursor.setPosition(x - xx, y - yy); std::cout << line; } Horizontal align must be done in a loop. Each line will be aligned differently based on its length and number of tabs. I will count one tab as 7 characters. For simplicity I will omit other control characters. To parse individual lines I will use stringstream and function getline likewise reading from file. In the loop I will print individual lines with their align. void printText(int x, int y, std::string text, HAlign halign=LEFT, VAlign valign=TOP) { int xx = 0, yy = 0; std::string line; int cnt = std::count(text.begin(), text.end(), '\\n'); switch (valign) { case TOP: yy = 0; break; case MIDDLE: yy = cnt / 2; break; case DOWN: yy = cnt; break; } std::istringstream separate(text); while(std::getline(separate, line)) { int tabs = 7 * std::count(line.begin(), line.end(), '\\t'); switch (halign) { case LEFT: xx = 0; break; case CENTER: xx = (line.length() + tabs - 1) / 2; break; case RIGHT: xx = line.length() + tabs - 1; break; } Cursor.setPosition(x - xx, (y++) - yy); std::cout << line; } } This screenshot has green text from Hobit and gray anchor point in the middle. Cursor.setColor(LIGHTGREEN); printText(40, 22, \"\\\"Good Morning!\\\" said Bilbo, and he meant it.\\n \\ The sun was shining, and the grass was very green.\\n \\ But Gandalf looked at him from under long bushy eyebrows\\n \\ that stuck out further than the brim of his shady hat.\", CENTER, MIDDLE); Cursor.printChar(40, 22, 'X', GRAY); Board game Board game has two parts, first I will print the grid and chessboard, second I will track mouse and move pieces if I click on them. Frame Printing of frame, the border of chessboard is simple. I use Cursor.printChar to draw all 4 borders and special symbols to corners. I use box-drawing characters to make borders nicer. They are defined in SWTI as abbreviations. For example, DLINE_UR is an abbreviation for DOUBLE LINE UP RIGHT. Full function is as follows. void printFrame(int x, int y, int columns, int rows) { Cursor.printChar(x, y, DLINE_UR); Cursor.printChar(x, y + rows + 1, DLINE_DR); Cursor.printChar(x + columns + 1, y, DLINE_UL); Cursor.printChar(x + columns + 1, y + rows + 1, DLINE_DL); for (int i = x + 1; i <= x + columns; i++) { Cursor.printChar(i, y, DLINE_H); Cursor.printChar(i, y + rows + 1, DLINE_H); } for (int i = y + 1; i <= y + rows; i++) { Cursor.printChar(x, i, DLINE_V); Cursor.printChar(x + columns + 1, i, DLINE_V); } } For this picture I set YELLOW color using Cursor.setColor and then called printFrame(0, 0, 35, 17); Chessboard Printing grid is more difficult it will need two cycles. I need to calculate size of each square and print its border. Let me start with corners as follows. void printGrid(int x, int y, int cx, int cy, int sx, int sy) { for (int py = 0, rx = x; py <= cy; py++, y += sy + 1) { for (int px = 0, x = rx; px <= cx; px++, x += sx + 1) { Cursor.printChar(x, y, LINE_HV); } } } Now I need to add borders for each square. This is more tedious because I want to use special ascii corners. Result is clean without sharp corners. void printGrid(int x, int y, int cx, int cy, int sx, int sy) { int px, py, i, rx = x; for (py = 0; py < cy; py++, y += sy + 1) { for (px = 0, x = rx; px < cx; px++, x += sx + 1) { if (px == 0 && py == 0) Cursor.printChar(x, y, LINE_UR); else if (py == 0) Cursor.printChar(x, y, LINE_HD); else if (px == 0) Cursor.printChar(x, y, LINE_VR); else Cursor.printChar(x, y, LINE_HV); for (i = x + 1; i <= x + sx; i++) Cursor.printChar(i, y, LINE_H); for (i = y + 1; i <= y + sy; i++) Cursor.printChar(x, i, LINE_V); } Cursor.printChar(x, y, (py == 0) ? LINE_UL : LINE_VL); for (i = y + 1; i <= y + sy; i++) Cursor.printChar(x, i, LINE_V); } for (px = 0, x = rx; px < cx; px++, x += sx + 1) { Cursor.printChar(x, y, (px == 0) ? LINE_DR : LINE_HU); for (i = x + 1; i <= x + sx; i++) Cursor.printChar(i, y, LINE_H); } Cursor.printChar(x, y, LINE_DL); } Pieces Let's add some movable pieces. I will create new class for one piece. Each piece is defined by its position, character and color. I will add also a state variable for later. class Piece { private: int x, y; char type; Color color; int state; }; This would be pretty useless class without some methods. I will add two public constructors and two getters, these getters will be special because they will return position in window rather than position in chessboard. For example, if piece position on board is x=1 and y=1, position in window will be [8, 4]. Finally I will add show method which takes the cursor to piece position and prints there a symbol. class Piece { public: Piece(int x, int y, char type, Color color) : x(x), y(y), type(type), color(color), state(0) { show(); } Piece() : Piece(0, 0, 'X', WHITE) {} int getColumns() { return 4 + x * 4; } int getRows() { return 2 + y * 2; } void show() { Cursor.printChar(getColumns(), getRows(), type, color); } void drag(); }; Lastly I will add drag method. This method is most complex because it behaves differently based on state variable. If state is 0, piece stays on its position. If state is 1, piece is being moved. To get mouse position I will call Mouse.getColumns() and Mouse.getRows(). To get left mouse button I will use Keyboard. I will also add absolute value to form a threshold, if user presses left button in same square but not necessary on piece location. I also need to prevent putting piece outside board or in the wrong square position. void Piece::drag() { if (Keyboard.getPressed(VK_LBUTTON) && abs(Mouse.getColumns() - getColumns()) < 3 \\ && abs(Mouse.getRows() - getRows()) < 2) state = 1; if (state == 1 && !Keyboard.getReleased(VK_LBUTTON)) { Cursor.printBlank(getColumns(), getRows()); x = (Mouse.getColumns() - 3) / 4; y = (Mouse.getRows() - 2) / 2; x = (std::min)((std::max)(x, 0), 7); y = (std::min)((std::max)(y, 0), 7); Cursor.printChar(getColumns(), getRows(), type, LIGHTYELLOW); } else if (state == 1) { state = 0; } } In main I will add individual pieces on board. I will also hide annoying blinking and selection. Without Window.hideSelection() clicking to console would select the text which is not what we want. Lastly, I need to loop through all pieces, show them and drag them. To continue making games, check out arcade game . int main() { Window.hideBlinking(); Window.hideSelection(); Cursor.setColor(YELLOW); printFrame(0, 0, 35, 17); Cursor.setColor(WHITE); printGrid(2, 1, 8, 8, 3, 1); Piece pieces[4] = { Piece(2, 2, 'X', LIGHTRED), Piece(2, 5, 'Y', LIGHTRED), Piece(5, 2, 'X', LIGHTBLUE), Piece(5, 5, 'Y', LIGHTBLUE) }; while(!Keyboard.get(VK_ESCAPE)) { for (auto& piece: pieces) piece.show(); for (auto& piece: pieces) piece.drag(); Keyboard.wait(30); } } Full code Code for board game is following. On the github you can find similar code with more comments for these examples. #include <iostream> #include <sstream> #include <algorithm> #include \"swti/swti.hpp\" void printFrame(int x, int y, int columns, int rows) { Cursor.printChar(x, y, DLINE_UR); Cursor.printChar(x, y + rows + 1, DLINE_DR); Cursor.printChar(x + columns + 1, y, DLINE_UL); Cursor.printChar(x + columns + 1, y + rows + 1, DLINE_DL); for (int i = x + 1; i <= x + columns; i++) { Cursor.printChar(i, y, DLINE_H); Cursor.printChar(i, y + rows + 1, DLINE_H); } for (int i = y + 1; i <= y + rows; i++) { Cursor.printChar(x, i, DLINE_V); Cursor.printChar(x + columns + 1, i, DLINE_V); } } void printGrid(int x, int y, int cx, int cy, int sx, int sy) { int px, py, i, rx = x; for (py = 0; py < cy; py++, y += sy + 1) { for (px = 0, x = rx; px < cx; px++, x += sx + 1) { if (px == 0 && py == 0) Cursor.printChar(x, y, LINE_UR); else if (py == 0) Cursor.printChar(x, y, LINE_HD); else if (px == 0) Cursor.printChar(x, y, LINE_VR); else Cursor.printChar(x, y, LINE_HV); for (i = x + 1; i <= x + sx; i++) Cursor.printChar(i, y, LINE_H); for (i = y + 1; i <= y + sy; i++) Cursor.printChar(x, i, LINE_V); } Cursor.printChar(x, y, (py == 0) ? LINE_UL : LINE_VL); for (i = y + 1; i <= y + sy; i++) Cursor.printChar(x, i, LINE_V); } for (px = 0, x = rx; px < cx; px++, x += sx + 1) { Cursor.printChar(x, y, (px == 0) ? LINE_DR : LINE_HU); for (i = x + 1; i <= x + sx; i++) Cursor.printChar(i, y, LINE_H); } Cursor.printChar(x, y, LINE_DL); } class Piece { private: int x, y; char type; Color color; int state; public: Piece(int x, int y, char type, Color color) : x(x), y(y), type(type), color(color), state(0) { show(); } Piece() : Piece(0, 0, 'X', WHITE) {} int getColumns() { return 4 + x * 4; } int getRows() { return 2 + y * 2; } void show() { Cursor.printChar(getColumns(), getRows(), type, color); } void drag(); }; void Piece::drag() { if (Keyboard.getPressed(VK_LBUTTON) && abs(Mouse.getColumns() - getColumns()) < 3 \\ && abs(Mouse.getRows() - getRows()) < 2) state = 1; if (state == 1 && !Keyboard.getReleased(VK_LBUTTON)) { Cursor.printBlank(getColumns(), getRows()); x = (Mouse.getColumns() - 3) / 4; y = (Mouse.getRows() - 2) / 2; x = (std::min)((std::max)(x, 0), 7); y = (std::min)((std::max)(y, 0), 7); Cursor.printChar(getColumns(), getRows(), type, LIGHTYELLOW); } else if (state == 1) { state = 0; } } int main() { Window.hideBlinking(); Window.hideSelection(); Cursor.setColor(YELLOW); printFrame(0, 0, 35, 17); Cursor.setColor(WHITE); printGrid(2, 1, 8, 8, 3, 1); Piece pieces[4] = { Piece(2, 2, 'X', LIGHTRED), Piece(2, 5, 'Y', LIGHTRED), Piece(5, 2, 'X', LIGHTBLUE), Piece(5, 5, 'Y', LIGHTBLUE) }; while(!Keyboard.get(VK_ESCAPE)) { for (auto& piece: pieces) piece.show(); for (auto& piece: pieces) piece.drag(); Keyboard.wait(30); } }","title":"Some examples"},{"location":"examples/examples/#some-examples","text":"Source examples.cpp includes miscellaneous functions that can be useful in variety games and applications. It includes simple board game and aligned text printing.","title":"Some examples"},{"location":"examples/examples/#text-aligment","text":"Let's start with the text. In order to differentiate various aligns, I will create two enums. One for horizontal align and second for vertical. enum HAlign { LEFT, CENTER, RIGHT }; enum VAlign { TOP, MIDDLE, DOWN }; My goal is to create function that takes position, string of text and align. I can calculate vertical align by counting number of new lines in text. That can be done using std::count from library. So far my function looks like this. It is missing horizontal align. void printText(int x, int y, std::string text, HAlign halign=LEFT, VAlign valign=TOP); { int xx = 0, yy = 0; int cnt = std::count(text.begin(), text.end(), '\\n'); switch (valign) { case TOP: yy = 0; break; case MIDDLE: yy = cnt / 2; break; case DOWN: yy = cnt; break; } Cursor.setPosition(x - xx, y - yy); std::cout << line; } Horizontal align must be done in a loop. Each line will be aligned differently based on its length and number of tabs. I will count one tab as 7 characters. For simplicity I will omit other control characters. To parse individual lines I will use stringstream and function getline likewise reading from file. In the loop I will print individual lines with their align. void printText(int x, int y, std::string text, HAlign halign=LEFT, VAlign valign=TOP) { int xx = 0, yy = 0; std::string line; int cnt = std::count(text.begin(), text.end(), '\\n'); switch (valign) { case TOP: yy = 0; break; case MIDDLE: yy = cnt / 2; break; case DOWN: yy = cnt; break; } std::istringstream separate(text); while(std::getline(separate, line)) { int tabs = 7 * std::count(line.begin(), line.end(), '\\t'); switch (halign) { case LEFT: xx = 0; break; case CENTER: xx = (line.length() + tabs - 1) / 2; break; case RIGHT: xx = line.length() + tabs - 1; break; } Cursor.setPosition(x - xx, (y++) - yy); std::cout << line; } } This screenshot has green text from Hobit and gray anchor point in the middle. Cursor.setColor(LIGHTGREEN); printText(40, 22, \"\\\"Good Morning!\\\" said Bilbo, and he meant it.\\n \\ The sun was shining, and the grass was very green.\\n \\ But Gandalf looked at him from under long bushy eyebrows\\n \\ that stuck out further than the brim of his shady hat.\", CENTER, MIDDLE); Cursor.printChar(40, 22, 'X', GRAY);","title":"Text aligment"},{"location":"examples/examples/#board-game","text":"Board game has two parts, first I will print the grid and chessboard, second I will track mouse and move pieces if I click on them.","title":"Board game"},{"location":"examples/examples/#frame","text":"Printing of frame, the border of chessboard is simple. I use Cursor.printChar to draw all 4 borders and special symbols to corners. I use box-drawing characters to make borders nicer. They are defined in SWTI as abbreviations. For example, DLINE_UR is an abbreviation for DOUBLE LINE UP RIGHT. Full function is as follows. void printFrame(int x, int y, int columns, int rows) { Cursor.printChar(x, y, DLINE_UR); Cursor.printChar(x, y + rows + 1, DLINE_DR); Cursor.printChar(x + columns + 1, y, DLINE_UL); Cursor.printChar(x + columns + 1, y + rows + 1, DLINE_DL); for (int i = x + 1; i <= x + columns; i++) { Cursor.printChar(i, y, DLINE_H); Cursor.printChar(i, y + rows + 1, DLINE_H); } for (int i = y + 1; i <= y + rows; i++) { Cursor.printChar(x, i, DLINE_V); Cursor.printChar(x + columns + 1, i, DLINE_V); } } For this picture I set YELLOW color using Cursor.setColor and then called printFrame(0, 0, 35, 17);","title":"Frame"},{"location":"examples/examples/#chessboard","text":"Printing grid is more difficult it will need two cycles. I need to calculate size of each square and print its border. Let me start with corners as follows. void printGrid(int x, int y, int cx, int cy, int sx, int sy) { for (int py = 0, rx = x; py <= cy; py++, y += sy + 1) { for (int px = 0, x = rx; px <= cx; px++, x += sx + 1) { Cursor.printChar(x, y, LINE_HV); } } } Now I need to add borders for each square. This is more tedious because I want to use special ascii corners. Result is clean without sharp corners. void printGrid(int x, int y, int cx, int cy, int sx, int sy) { int px, py, i, rx = x; for (py = 0; py < cy; py++, y += sy + 1) { for (px = 0, x = rx; px < cx; px++, x += sx + 1) { if (px == 0 && py == 0) Cursor.printChar(x, y, LINE_UR); else if (py == 0) Cursor.printChar(x, y, LINE_HD); else if (px == 0) Cursor.printChar(x, y, LINE_VR); else Cursor.printChar(x, y, LINE_HV); for (i = x + 1; i <= x + sx; i++) Cursor.printChar(i, y, LINE_H); for (i = y + 1; i <= y + sy; i++) Cursor.printChar(x, i, LINE_V); } Cursor.printChar(x, y, (py == 0) ? LINE_UL : LINE_VL); for (i = y + 1; i <= y + sy; i++) Cursor.printChar(x, i, LINE_V); } for (px = 0, x = rx; px < cx; px++, x += sx + 1) { Cursor.printChar(x, y, (px == 0) ? LINE_DR : LINE_HU); for (i = x + 1; i <= x + sx; i++) Cursor.printChar(i, y, LINE_H); } Cursor.printChar(x, y, LINE_DL); }","title":"Chessboard"},{"location":"examples/examples/#pieces","text":"Let's add some movable pieces. I will create new class for one piece. Each piece is defined by its position, character and color. I will add also a state variable for later. class Piece { private: int x, y; char type; Color color; int state; }; This would be pretty useless class without some methods. I will add two public constructors and two getters, these getters will be special because they will return position in window rather than position in chessboard. For example, if piece position on board is x=1 and y=1, position in window will be [8, 4]. Finally I will add show method which takes the cursor to piece position and prints there a symbol. class Piece { public: Piece(int x, int y, char type, Color color) : x(x), y(y), type(type), color(color), state(0) { show(); } Piece() : Piece(0, 0, 'X', WHITE) {} int getColumns() { return 4 + x * 4; } int getRows() { return 2 + y * 2; } void show() { Cursor.printChar(getColumns(), getRows(), type, color); } void drag(); }; Lastly I will add drag method. This method is most complex because it behaves differently based on state variable. If state is 0, piece stays on its position. If state is 1, piece is being moved. To get mouse position I will call Mouse.getColumns() and Mouse.getRows(). To get left mouse button I will use Keyboard. I will also add absolute value to form a threshold, if user presses left button in same square but not necessary on piece location. I also need to prevent putting piece outside board or in the wrong square position. void Piece::drag() { if (Keyboard.getPressed(VK_LBUTTON) && abs(Mouse.getColumns() - getColumns()) < 3 \\ && abs(Mouse.getRows() - getRows()) < 2) state = 1; if (state == 1 && !Keyboard.getReleased(VK_LBUTTON)) { Cursor.printBlank(getColumns(), getRows()); x = (Mouse.getColumns() - 3) / 4; y = (Mouse.getRows() - 2) / 2; x = (std::min)((std::max)(x, 0), 7); y = (std::min)((std::max)(y, 0), 7); Cursor.printChar(getColumns(), getRows(), type, LIGHTYELLOW); } else if (state == 1) { state = 0; } } In main I will add individual pieces on board. I will also hide annoying blinking and selection. Without Window.hideSelection() clicking to console would select the text which is not what we want. Lastly, I need to loop through all pieces, show them and drag them. To continue making games, check out arcade game . int main() { Window.hideBlinking(); Window.hideSelection(); Cursor.setColor(YELLOW); printFrame(0, 0, 35, 17); Cursor.setColor(WHITE); printGrid(2, 1, 8, 8, 3, 1); Piece pieces[4] = { Piece(2, 2, 'X', LIGHTRED), Piece(2, 5, 'Y', LIGHTRED), Piece(5, 2, 'X', LIGHTBLUE), Piece(5, 5, 'Y', LIGHTBLUE) }; while(!Keyboard.get(VK_ESCAPE)) { for (auto& piece: pieces) piece.show(); for (auto& piece: pieces) piece.drag(); Keyboard.wait(30); } }","title":"Pieces"},{"location":"examples/examples/#full-code","text":"Code for board game is following. On the github you can find similar code with more comments for these examples. #include <iostream> #include <sstream> #include <algorithm> #include \"swti/swti.hpp\" void printFrame(int x, int y, int columns, int rows) { Cursor.printChar(x, y, DLINE_UR); Cursor.printChar(x, y + rows + 1, DLINE_DR); Cursor.printChar(x + columns + 1, y, DLINE_UL); Cursor.printChar(x + columns + 1, y + rows + 1, DLINE_DL); for (int i = x + 1; i <= x + columns; i++) { Cursor.printChar(i, y, DLINE_H); Cursor.printChar(i, y + rows + 1, DLINE_H); } for (int i = y + 1; i <= y + rows; i++) { Cursor.printChar(x, i, DLINE_V); Cursor.printChar(x + columns + 1, i, DLINE_V); } } void printGrid(int x, int y, int cx, int cy, int sx, int sy) { int px, py, i, rx = x; for (py = 0; py < cy; py++, y += sy + 1) { for (px = 0, x = rx; px < cx; px++, x += sx + 1) { if (px == 0 && py == 0) Cursor.printChar(x, y, LINE_UR); else if (py == 0) Cursor.printChar(x, y, LINE_HD); else if (px == 0) Cursor.printChar(x, y, LINE_VR); else Cursor.printChar(x, y, LINE_HV); for (i = x + 1; i <= x + sx; i++) Cursor.printChar(i, y, LINE_H); for (i = y + 1; i <= y + sy; i++) Cursor.printChar(x, i, LINE_V); } Cursor.printChar(x, y, (py == 0) ? LINE_UL : LINE_VL); for (i = y + 1; i <= y + sy; i++) Cursor.printChar(x, i, LINE_V); } for (px = 0, x = rx; px < cx; px++, x += sx + 1) { Cursor.printChar(x, y, (px == 0) ? LINE_DR : LINE_HU); for (i = x + 1; i <= x + sx; i++) Cursor.printChar(i, y, LINE_H); } Cursor.printChar(x, y, LINE_DL); } class Piece { private: int x, y; char type; Color color; int state; public: Piece(int x, int y, char type, Color color) : x(x), y(y), type(type), color(color), state(0) { show(); } Piece() : Piece(0, 0, 'X', WHITE) {} int getColumns() { return 4 + x * 4; } int getRows() { return 2 + y * 2; } void show() { Cursor.printChar(getColumns(), getRows(), type, color); } void drag(); }; void Piece::drag() { if (Keyboard.getPressed(VK_LBUTTON) && abs(Mouse.getColumns() - getColumns()) < 3 \\ && abs(Mouse.getRows() - getRows()) < 2) state = 1; if (state == 1 && !Keyboard.getReleased(VK_LBUTTON)) { Cursor.printBlank(getColumns(), getRows()); x = (Mouse.getColumns() - 3) / 4; y = (Mouse.getRows() - 2) / 2; x = (std::min)((std::max)(x, 0), 7); y = (std::min)((std::max)(y, 0), 7); Cursor.printChar(getColumns(), getRows(), type, LIGHTYELLOW); } else if (state == 1) { state = 0; } } int main() { Window.hideBlinking(); Window.hideSelection(); Cursor.setColor(YELLOW); printFrame(0, 0, 35, 17); Cursor.setColor(WHITE); printGrid(2, 1, 8, 8, 3, 1); Piece pieces[4] = { Piece(2, 2, 'X', LIGHTRED), Piece(2, 5, 'Y', LIGHTRED), Piece(5, 2, 'X', LIGHTBLUE), Piece(5, 5, 'Y', LIGHTBLUE) }; while(!Keyboard.get(VK_ESCAPE)) { for (auto& piece: pieces) piece.show(); for (auto& piece: pieces) piece.drag(); Keyboard.wait(30); } }","title":"Full code"},{"location":"examples/hello/","text":"Hello world I want to print colored logo of SWTI and yellow text Hello world to middle of fullscreen window. Start I will begin by simple hello world, check that this code compiles and executes correctly. If not, refer to README and solve the issue before continuing. #include <iostream> #include \"swti/swti.hpp\" int main() { std::cout << \"Hello World!\" << std::endl; return 0; } Logo I can create SWTI logo by using Cursor.printChar which prints a character at position, optionally with color. I will print individual characters of SWTI, each with different color and different position. #include <iostream> #include \"swti/swti.hpp\" int main() { Cursor.printChar(0, 0, 'S', YELLOW); Cursor.printChar(1, 0, 'W', LIGHTRED); Cursor.printChar(2, 0, 'T', LIGHTBLUE); Cursor.printChar(3, 0, 'I', LIGHTGREEN); return 0; } Function I can make a function that prints SWTI logo at any position. Then I can use Cursor.setPosition and Cursor.setColor to set position and color of next written text. I can write \"Hello world\". #include <iostream> #include \"swti/swti.hpp\" void printLogo(int x, int y) { Cursor.printChar(x++, y, 'S', YELLOW); Cursor.printChar(x++, y, 'W', LIGHTRED); Cursor.printChar(x++, y, 'T', LIGHTBLUE); Cursor.printChar(x++, y, 'I', LIGHTGREEN); } int main() { printLogo(0, 0); Cursor.setPosition(5, 0); Cursor.setColor(YELLOW); std::cout << \"Hello world!\"; return 0; } Colors Window.setDefaultColor changes our color pallete with different colors. I will use Window.setDefaultColor to change BLACK background to dark blue and set YELLOW to different HEX value. #include <iostream> #include \"swti/swti.hpp\" void printLogo(int x, int y) { Cursor.printChar(x++, y, 'S', YELLOW); Cursor.printChar(x++, y, 'W', LIGHTRED); Cursor.printChar(x++, y, 'T', LIGHTBLUE); Cursor.printChar(x++, y, 'I', LIGHTGREEN); } int main() { Window.setDefaultColor(BLACK, RGB(16, 20, 28)); Window.setDefaultColor(YELLOW, HEX(0xf5f118)); printLogo(0, 0); Cursor.setPosition(5, 0); Cursor.setColor(YELLOW); std::cout << \"Hello world!\"; return 0; } Window functions I calculate font size using Window.getScreenHeight and then use Cursor.setFontSize I call Window.setFullscreenBorderless to set window to fullsreen. Finally can factor out these functions to simple setup() function. #include <iostream> #include \"swti/swti.hpp\" void setup() { Window.setDefaultColor(BLACK, RGB(16, 20, 28)); Window.setDefaultColor(YELLOW, HEX(0xf5f118)); int size = Window.getScreenHeight() / 15; Cursor.setFontSize(size); Window.setFullscreenBorderless(); Window.hideBlinking(); } void printLogo(int x, int y) { Cursor.printChar(x++, y, 'S', YELLOW); Cursor.printChar(x++, y, 'W', LIGHTRED); Cursor.printChar(x++, y, 'T', LIGHTBLUE); Cursor.printChar(x++, y, 'I', LIGHTGREEN); } int main() { setup(); printLogo(0, 0); Cursor.setPosition(5, 0); Cursor.setColor(YELLOW); std::cout << \"Hello world!\"; return 0; } Full code I can calculate middle position using Window.getColumns and Window.getRows. If I divide both numbers by two, I get middle and center. I will then substract some number to adjust it to our needs. Lastly, I will call Keyboard.waitUser(); to end the main and use Window.hideBlinking(); to stop white blinking cursor. #include <iostream> #include \"swti/swti.hpp\" // set fullsreen, font size and colors void setup() { Window.setDefaultColor(BLACK, RGB(16, 20, 28)); Window.setDefaultColor(YELLOW, HEX(0xf5f118)); int size = Window.getScreenHeight() / 15; Cursor.setFontSize(size); Window.setFullscreenBorderless(); Window.hideBlinking(); } // simple function to print colorful logo void printLogo(int x, int y) { Cursor.printChar(x++, y, 'S', YELLOW); Cursor.printChar(x++, y, 'W', LIGHTRED); Cursor.printChar(x++, y, 'T', LIGHTBLUE); Cursor.printChar(x++, y, 'I', LIGHTGREEN); } // main function will be called first int main() { setup(); int middle, center; middle = Window.getColumns() / 2 - 8; center = Window.getRows() / 2 - 2; printLogo(middle, center); Cursor.setPosition(middle + 5, center); Cursor.setColor(YELLOW); cout << \"Hello world!\"; Keyboard.waitUser(); return 0; }","title":"Hello world"},{"location":"examples/hello/#hello-world","text":"I want to print colored logo of SWTI and yellow text Hello world to middle of fullscreen window.","title":"Hello world"},{"location":"examples/hello/#start","text":"I will begin by simple hello world, check that this code compiles and executes correctly. If not, refer to README and solve the issue before continuing. #include <iostream> #include \"swti/swti.hpp\" int main() { std::cout << \"Hello World!\" << std::endl; return 0; }","title":"Start"},{"location":"examples/hello/#logo","text":"I can create SWTI logo by using Cursor.printChar which prints a character at position, optionally with color. I will print individual characters of SWTI, each with different color and different position. #include <iostream> #include \"swti/swti.hpp\" int main() { Cursor.printChar(0, 0, 'S', YELLOW); Cursor.printChar(1, 0, 'W', LIGHTRED); Cursor.printChar(2, 0, 'T', LIGHTBLUE); Cursor.printChar(3, 0, 'I', LIGHTGREEN); return 0; }","title":"Logo"},{"location":"examples/hello/#function","text":"I can make a function that prints SWTI logo at any position. Then I can use Cursor.setPosition and Cursor.setColor to set position and color of next written text. I can write \"Hello world\". #include <iostream> #include \"swti/swti.hpp\" void printLogo(int x, int y) { Cursor.printChar(x++, y, 'S', YELLOW); Cursor.printChar(x++, y, 'W', LIGHTRED); Cursor.printChar(x++, y, 'T', LIGHTBLUE); Cursor.printChar(x++, y, 'I', LIGHTGREEN); } int main() { printLogo(0, 0); Cursor.setPosition(5, 0); Cursor.setColor(YELLOW); std::cout << \"Hello world!\"; return 0; }","title":"Function"},{"location":"examples/hello/#colors","text":"Window.setDefaultColor changes our color pallete with different colors. I will use Window.setDefaultColor to change BLACK background to dark blue and set YELLOW to different HEX value. #include <iostream> #include \"swti/swti.hpp\" void printLogo(int x, int y) { Cursor.printChar(x++, y, 'S', YELLOW); Cursor.printChar(x++, y, 'W', LIGHTRED); Cursor.printChar(x++, y, 'T', LIGHTBLUE); Cursor.printChar(x++, y, 'I', LIGHTGREEN); } int main() { Window.setDefaultColor(BLACK, RGB(16, 20, 28)); Window.setDefaultColor(YELLOW, HEX(0xf5f118)); printLogo(0, 0); Cursor.setPosition(5, 0); Cursor.setColor(YELLOW); std::cout << \"Hello world!\"; return 0; }","title":"Colors"},{"location":"examples/hello/#window-functions","text":"I calculate font size using Window.getScreenHeight and then use Cursor.setFontSize I call Window.setFullscreenBorderless to set window to fullsreen. Finally can factor out these functions to simple setup() function. #include <iostream> #include \"swti/swti.hpp\" void setup() { Window.setDefaultColor(BLACK, RGB(16, 20, 28)); Window.setDefaultColor(YELLOW, HEX(0xf5f118)); int size = Window.getScreenHeight() / 15; Cursor.setFontSize(size); Window.setFullscreenBorderless(); Window.hideBlinking(); } void printLogo(int x, int y) { Cursor.printChar(x++, y, 'S', YELLOW); Cursor.printChar(x++, y, 'W', LIGHTRED); Cursor.printChar(x++, y, 'T', LIGHTBLUE); Cursor.printChar(x++, y, 'I', LIGHTGREEN); } int main() { setup(); printLogo(0, 0); Cursor.setPosition(5, 0); Cursor.setColor(YELLOW); std::cout << \"Hello world!\"; return 0; }","title":"Window functions"},{"location":"examples/hello/#full-code","text":"I can calculate middle position using Window.getColumns and Window.getRows. If I divide both numbers by two, I get middle and center. I will then substract some number to adjust it to our needs. Lastly, I will call Keyboard.waitUser(); to end the main and use Window.hideBlinking(); to stop white blinking cursor. #include <iostream> #include \"swti/swti.hpp\" // set fullsreen, font size and colors void setup() { Window.setDefaultColor(BLACK, RGB(16, 20, 28)); Window.setDefaultColor(YELLOW, HEX(0xf5f118)); int size = Window.getScreenHeight() / 15; Cursor.setFontSize(size); Window.setFullscreenBorderless(); Window.hideBlinking(); } // simple function to print colorful logo void printLogo(int x, int y) { Cursor.printChar(x++, y, 'S', YELLOW); Cursor.printChar(x++, y, 'W', LIGHTRED); Cursor.printChar(x++, y, 'T', LIGHTBLUE); Cursor.printChar(x++, y, 'I', LIGHTGREEN); } // main function will be called first int main() { setup(); int middle, center; middle = Window.getColumns() / 2 - 8; center = Window.getRows() / 2 - 2; printLogo(middle, center); Cursor.setPosition(middle + 5, center); Cursor.setColor(YELLOW); cout << \"Hello world!\"; Keyboard.waitUser(); return 0; }","title":"Full code"},{"location":"wiki/cursor/","text":"Cursor Cursor writes in console window all text. You can change its position, color and font. Table of Set functions bool setPosition(int x, int y) bool setColor(Color foreground, Color background=CURRENT) bool setFontSize(int size) bool setFontChars(int columns, int rows) bool setFontPixels(int width, int height) bool setFontType(wstring name) Table of Printing functions bool printChar(int x, int y, int character, Color color=CURRENT) bool printBlank(int x, int y) bool clearScreen() Table of Get functions int getX() int getY() Color getColorForeground() Color getColorBackground() int getFontWidth() int getFontHeight() int getFontSize() wstring getFontType() Information Position The cursor position indicates where text is going to be written. It is used every time you write a text. It is changed automatically but setting it manually provides a useful custom functionality. The unit of position is a single character . You set position of cursor by calling a function with specified number of columns and rows . The top left corner of the window is marked as [0,0] or more precisely x = 0 and y = 0 . The opposite bottom right corner can be obtained using Window functions. The character count of the window tells you many characters you can write in the current console without. Characters are not screen pixels . The actual character size in pixels depends on many factors including screen size and font size . The default value is about 16\u00d724 pixels large. Also check out the font information. Color Cursor color can be used to highlight different texts and to make simple graphics. There are 16 different colors to choose from. They are defined in as an integer enumeration called Color . This means you use Color constants only by their name without using object notation. You can change their value using Window.setDefaultColor . Color Constant HEX value Color Constant HEX value BLACK #0c0c0c GRAY #767676 BLUE #0037da LIGHTBLUE #3b78ff GREEN #13a10e LIGHTGREEN #16c60c CYAN #3a96dd LIGHTCYAN #61d6d6 RED #c50f1f LIGHTRED #e74856 MAGENTA #881798 LIGHTMAGENTA #b4009e YELLOW #c19c00 LIGHTYELLOW #f9f1a5 LIGHTGRAY #cccccc WHITE #f2f2f2 CURRENT is a special type of color. It is the color which is at the moment in use. Font Font includes font size and font type. You can't have in one application characters of different sizes and fonts. Setting font changes all text in console therefore should be called at the start of the application. A good practice is to change a font only at the start of an application. Font size is measured by size of one character. When setting a new font size you should be using a setFontSize() or setFontChars() . These functions change font size in respect of the console window size. It makes porting application to different screen size much more easier. For headers and large texts you can use a ASCII Text generator. When printing any ascii art, do not forget to add escape characters. Change all \\ to \\\\ . using namespace std; // use standard library for output cout << \" _____ _____ _____ _______ _________ _____ \" << endl; cout << \" /\\\\ / ____|_ _|_ _| / ____\\\\ \\\\ / /__ __|_ _| \" << endl; cout << \" / \\\\ | | | | | | | (___ \\\\ \\\\ /\\\\ / / | | | | \" << endl; cout << \" / /\\\\ \\\\| | | | | | \\\\___ \\\\ \\\\ \\\\/ \\\\/ / | | | |\" << endl; cout << \" / ____ \\\\ |____ _| |_ _| |_ ____) | \\\\ /\\\\ / | | _| |_ \" << endl; cout << \"/_/ \\\\_\\\\_____|_____|_____| |_____/ \\\\/ \\\\/ |_| |_____| \" << endl; Font type is style of characters. Different font families exist and you can choose whichever you prefer. Windows console supports many monospace fonts with most usable being Consolas , Courier , Lucida Console , MS Gothic , Terminal . Use setFontType() function to set your favorite font. You can also try some proportional fonts like Arial , Times New Roman , Tahoma , Impact , Modern , Roman , Symbol , Segoe UI . However some of these are a glitchy and should be used with caution. You can also try other fonts. This image shows some of the fonts, but keep in mind that you can use only one font family at a time. Constants Newer versions of windows console stopped supporting all ascii characters. You can use Windows 1250 or even UTF8 ( stackoverflow ). You can also use following constants in your code. These box-drawing characters will work in both old and new windows console. Instead of writing Cursor.printChar(197) you can use handy Cursor.printChar(LINE_HV) . Char Constant Description Char Constant Description \u2500 LINE_H horizontal \u2550 DLINE_H horizontal \u2502 LINE_V vertical \u2551 DLINE_V vertical \u250c LINE_UR up right \u2554 DLINE_UR up right \u2510 LINE_UL up left \u2557 DLINE_UL up left \u2514 LINE_DR down right \u255a DLINE_DR down right \u2518 LINE_DL down left \u255d DLINE_DL down left \u2534 LINE_HU horizontal up \u2569 DLINE_HU horizontal up \u252c LINE_HD horizontal down \u2566 DLINE_HD horizontal down \u251c LINE_VR vertical right \u2560 DLINE_VR vertical right \u2524 LINE_VL vertical left \u2563 DLINE_VL vertical left \u253c LINE_HV crossed lines \u256c DLINE_HV crossed lines FILL_B blank space \u00ab ARROWS_L left arrows \u2591 FILL_L low dotted \u00bb ARROWS_R right arrows \u2592 FILL_M medium dotted \u2584 SQUARE_D square down \u2593 FILL_H highly dotted \u2580 SQUARE_U square up \u2588 FILL_F full filled \u25a0 SQUARE_M square middle Examples Following example writes colorful Hello world on screen with specified position. Cursor.setPosition(5,2); Cursor.setColor(YELLOW); std::cout << \"Hello world!\" << std::endl; These are examples show usage of colors. Window.setDefaultColor(MAGENTA, HEX(0xe0248c)); Cursor.setColor(MAGENTA, LIGHTCYAN); Cursor.printChar(12, 3, 'D', GREEN); Cursor.printChar(4, 9, FILL_F, GREEN); Window.setColor(CURRENT, WHITE); These are examples where usage of font. Cursor.setFontSize(22); Cursor.setFontType(L\"Lucida Console\"); std::cout << \"Printing some text\"; Functions bool setPosition(int x, int y) This function sets the position of cursor. When you call any standard function to print a text, first character will be on the set position. Next characters will continue right and down. The cursor position will not change if given position is outside the console window. Parameters int x - position in columns int y - position in rows Return value Return type is bool . Return value is true if position was set successfully or position is outside the console window. Return value is false if unexpected error occurs. Example This example sets the cursor position to coordinates [12, 8] and writes there using C++ standard output, printf and putchar. Cursor.setPosition(12, 8); std::cout << \"Hello \"; printf(\"world\"); putchar('!'); bool setColor(Color foreground, Color background=CURRENT) This function sets the color of cursor. It changes the foreground color of the printed characters and optionally you can also specify a background color. This function doesn't change already written characters (you can use Window.setColor() for that). Parameters Color - any color constant, foreground text color Color - (optional) any color, default is current background text color Return value Return type is bool . Return value is true if color was set successfully, false if any error occurs. Example This example writes two texts on the screen. First is a yellow text without specific background color, second is magenta text with light cyan background. Cursor.setColor(YELLOW); std::cout << \"Yellow text without background color\"; Cursor.setColor(MAGENTA, LIGHTCYAN); std::cout << \"Magenta text on light cyan background\"; bool setFontSize(int size) This function sets the height of characters in console. It calculates size proportionally to current console size. It is the most convenient and easy way to set the font size. Setting font size changes all text in console. Parameters int - new character height. Size 15 is approximately 1/50 of the console height. Return value Return type is bool . Return value is true if font was set successfully, false if any error occurs. Example This example writes a text on screen with size of 28. Then it waits for user input. After user presses a key, it resizes the console size and adjusts the font size to new console size. Cursor.setFontSize(28); std::cout << \"Press a key to change the screen size...\" << std::endl; Keyboard.waitUser(); Window.setSizePixels(1280,720); Cursor.setFontSize(28); bool setFontChars(int columns, int rows) This function sets the font size in console. It calculates size proportionally to a given screen columns and rows. Setting font size changes all text in console. Parameters int - at most how many columns will font occupy int - at most how many rows will font occupy Return value Return type is bool . Return value is true if font was set successfully, false if any error occurs. Example This example sets the font to squares and writes a filled tic tac toe board. Window.setSizeChars(100, 50); Cursor.setFontChars(50, 50); std::cout << \"XOX\\nOXO\\nXOX\" << std::endl; bool setFontPixels(int width, int height) This function sets the font size in console. It sets the font equal to pixels. The result of this function depends heavily on console screen size in pixels. You probably should use pixel independent functions like setFontSize or setFontChars . Setting font size changes all text in console. Parameters int - width of font in pixels int - height of font in pixels Return value Return type is bool . Return value is true if font was set successfully, false if any error occurs. Example This example sets the font to Window.setSizeChars(100, 50); Cursor.setFontChars(50, 50); std::cout << \"XOX\\nOXO\\nXOX\" << std::endl; bool setFontType(wstring name) This function sets the font in console. The most common fonts are Consolas , Courier , Lucida Console , MS Gothic , Terminal . Setting font changes all text in console. More information about fonts is here . Parameters wstring - name of font as wide string. You can call this function without creating variable (see example) Return value Return type is bool . Return value is true if font was set successfully, false if any error occurs. Example This example sets the font to Lucida Console and then changes the font size. Notice that the wide string is created using L prefix. Cursor.setFontType(L\"Lucida Console\"); Cursor.setFontSize(28); bool printChar(int x, int y, int character, Color color=CURRENT) This function prints one character on specified position. Additionally it can change a cursor color. To print a blank character you can use printBlank . To print more characters, use a setPosition and standard output. Parameters int - position in columns int - position in rows int - any character or Constant . Color - (optional) any Color constant, default is CURRENT Return value Return type is bool . Return value is true if everything works, false if any error occurs. If coordinates are outside screen it prints nothing and returns true . Example This is example writes a horizontal symbol on specified position. Then it writes W letter if W key was pressed and hides it after release. Cursor.printChar(3, 2, DLINE_V, LIGHTBLUE); if (Keyboard.getPressed('W')) { Cursor.printChar(11, 5, 'W'); } if (Keyboard.getReleased('W')) { Cursor.printBlank(11, 5); } bool printBlank(int x, int y) This function prints blank character on specified position. To print a other characters you can use printChar . To print more characters, use a setPosition and standard output. Parameters int - position in columns int - position in rows Return value Return type is bool . Return value is true if everything works, false if any error occurs. If coordinates are outside screen it prints nothing and returns true . Example This is example creates a simple animation of X moving to right of the screen. for (int i = 1; i <= 16; i++) { Cursor.printChar(i, 0, 'X', LIGHTGREEN); Cursor.printBlank(i-1, 0); Keyboard.wait(30); } bool clearScreen() This function fills entire console with blank characters. To hide only few characters you should use printBlank . This function is a replacement for overused system(\"cls\") . It is a more clean way to clear window. Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, false if any error occurs. Example This is example writes some text and then waits for user. After user presses a button, it clears the window. std::cout << \"Welcome in this awesome application.\"; Keyboard.waitUser(); Cursor.clearScreen(); std::cout << \"Do you want to show settings menu?\"; int getX() This function gets x coordinate of cursor. After start of the console program, cursor is automatically set to the top left corner and is moved by printing text. You can use this function if you don't know cursor coordinates, for example in functions. The best strategy is to save the position in local variable instead of calling this function in every step. Parameters This function doesn't have any parameters. Return value Return type is int . Return value is column position of cursor. Example This example prints a Kryten quote and warns the programmer that they forget to put escape character in it. std::cout << \"I knew I was lying. No silicon heaven?\" std::cout << \"Preposterous! Where would all the calculators go?\"; if (Cursor.getX() > 80) { std::cout << std::endl << \"Line is too long, try adding \\\\n in it\"; } int getY() This function gets y coordinate of cursor. After start of the console program, cursor is automatically set to the top left corner and is moved by printing text. You can use this function if you don't know cursor coordinates, for example in functions. The best strategy is to save the position in local variable instead of calling this function in every step. Parameters This function doesn't have any parameters. Return value Return type is int . Return value is row position of cursor. Example This example prints a simple rectangle at cursor position. Notice that we do not need to print end of line characters. int cx = Cursor.getX(); int cy = Cursor.getY(); for (int y = cy; y < cy+5; y++) { Cursor.setPosition(cx, y); std::cout << \"~~~~~~\"; } Color getColorForeground() This function returns printing color of the cursor. LIGHTGRAY is usually the default color. To change color instead, use Cursor.setColor(). Parameters This function doesn't have any parameters. Return value Return type is Color . Return value is color constant. Only if error occurs, return value is CURRENT. Example This example writes text only if cursor color is light gray. if (Cursor.getColorForeground() == LIGHTGRAY) { std::cout << \"You are using gray cursor color.\"; } Color getColorBackground() This function returns background printing color of the cursor. BLACK is usually the default color. To change color instead, use Cursor.setColor(). Parameters This function doesn't have any parameters. Return value Return type is Color . Return value is color constant. Only if error occurs, return value is CURRENT. Example This example changes background color for full console window to black. if (Cursor.getColorForeground() != BLACK) { Window.setColor(CURRENT, BLACK); } int getFontWidth() This function returns pixel width of font . To get number of columns in console use Window.getColumns() instead. Parameters This function doesn't have any parameters. Return value Return type is int . Return value is width of cursor in pixels. Example This example writes font size ratio to console. double cursor_ratio = (double) Cursor.getFontWidth() / Cursor.getFontHeight(); std::cout << \"Ratio is \" << cursor_ratio; int getFontHeight() This function returns pixel height of font . To get number of rows in console use Window.getRows() instead. Parameters This function doesn't have any parameters. Return value Return type is int . Return value is height of cursor in pixels. Example This example writes font size ratio to console. double scale = (double) 100 * Cursor.getFontHeight() / Window.getHeight(); std::cout << \"Your current scale is \" << scale; int getFontSize() This function returns unit height of font . The number can differ from last Cursor.setFontSize due to different console size and low integer precision. Parameters This function doesn't have any parameters. Return value Return type is int . Return value is size of cursor in pixels. Example This example sets the font to twice the size. int size = Cursor.getFontSize(); Cursor.getFontSize(size * 2); std::cout << \"Twice the power\"; wstring getFontType() This function returns name of console font . Returned font is stored as wide string, meaning non English letters can be also returned. To print wide string use wcout instead of cout. Parameters This function doesn't have any parameters. Return value Return type is wstring . Return value is wide string containing console font name. Example This function sets console font to Terminal if it is not already in use. std::wstring family = Cursor.getFontType(); if (family != L\"Terminal\") { std::wcout << \"Changing font from \" << family << \" to Terminal.\"; Cursor.setFontType(L\"Terminal\"); }","title":"Cursor"},{"location":"wiki/cursor/#cursor","text":"Cursor writes in console window all text. You can change its position, color and font. Table of Set functions bool setPosition(int x, int y) bool setColor(Color foreground, Color background=CURRENT) bool setFontSize(int size) bool setFontChars(int columns, int rows) bool setFontPixels(int width, int height) bool setFontType(wstring name) Table of Printing functions bool printChar(int x, int y, int character, Color color=CURRENT) bool printBlank(int x, int y) bool clearScreen() Table of Get functions int getX() int getY() Color getColorForeground() Color getColorBackground() int getFontWidth() int getFontHeight() int getFontSize() wstring getFontType()","title":"Cursor"},{"location":"wiki/cursor/#information","text":"","title":"Information"},{"location":"wiki/cursor/#position","text":"The cursor position indicates where text is going to be written. It is used every time you write a text. It is changed automatically but setting it manually provides a useful custom functionality. The unit of position is a single character . You set position of cursor by calling a function with specified number of columns and rows . The top left corner of the window is marked as [0,0] or more precisely x = 0 and y = 0 . The opposite bottom right corner can be obtained using Window functions. The character count of the window tells you many characters you can write in the current console without. Characters are not screen pixels . The actual character size in pixels depends on many factors including screen size and font size . The default value is about 16\u00d724 pixels large. Also check out the font information.","title":"Position"},{"location":"wiki/cursor/#color","text":"Cursor color can be used to highlight different texts and to make simple graphics. There are 16 different colors to choose from. They are defined in as an integer enumeration called Color . This means you use Color constants only by their name without using object notation. You can change their value using Window.setDefaultColor . Color Constant HEX value Color Constant HEX value BLACK #0c0c0c GRAY #767676 BLUE #0037da LIGHTBLUE #3b78ff GREEN #13a10e LIGHTGREEN #16c60c CYAN #3a96dd LIGHTCYAN #61d6d6 RED #c50f1f LIGHTRED #e74856 MAGENTA #881798 LIGHTMAGENTA #b4009e YELLOW #c19c00 LIGHTYELLOW #f9f1a5 LIGHTGRAY #cccccc WHITE #f2f2f2 CURRENT is a special type of color. It is the color which is at the moment in use.","title":"Color"},{"location":"wiki/cursor/#font","text":"Font includes font size and font type. You can't have in one application characters of different sizes and fonts. Setting font changes all text in console therefore should be called at the start of the application. A good practice is to change a font only at the start of an application. Font size is measured by size of one character. When setting a new font size you should be using a setFontSize() or setFontChars() . These functions change font size in respect of the console window size. It makes porting application to different screen size much more easier. For headers and large texts you can use a ASCII Text generator. When printing any ascii art, do not forget to add escape characters. Change all \\ to \\\\ . using namespace std; // use standard library for output cout << \" _____ _____ _____ _______ _________ _____ \" << endl; cout << \" /\\\\ / ____|_ _|_ _| / ____\\\\ \\\\ / /__ __|_ _| \" << endl; cout << \" / \\\\ | | | | | | | (___ \\\\ \\\\ /\\\\ / / | | | | \" << endl; cout << \" / /\\\\ \\\\| | | | | | \\\\___ \\\\ \\\\ \\\\/ \\\\/ / | | | |\" << endl; cout << \" / ____ \\\\ |____ _| |_ _| |_ ____) | \\\\ /\\\\ / | | _| |_ \" << endl; cout << \"/_/ \\\\_\\\\_____|_____|_____| |_____/ \\\\/ \\\\/ |_| |_____| \" << endl; Font type is style of characters. Different font families exist and you can choose whichever you prefer. Windows console supports many monospace fonts with most usable being Consolas , Courier , Lucida Console , MS Gothic , Terminal . Use setFontType() function to set your favorite font. You can also try some proportional fonts like Arial , Times New Roman , Tahoma , Impact , Modern , Roman , Symbol , Segoe UI . However some of these are a glitchy and should be used with caution. You can also try other fonts. This image shows some of the fonts, but keep in mind that you can use only one font family at a time.","title":"Font"},{"location":"wiki/cursor/#constants","text":"Newer versions of windows console stopped supporting all ascii characters. You can use Windows 1250 or even UTF8 ( stackoverflow ). You can also use following constants in your code. These box-drawing characters will work in both old and new windows console. Instead of writing Cursor.printChar(197) you can use handy Cursor.printChar(LINE_HV) . Char Constant Description Char Constant Description \u2500 LINE_H horizontal \u2550 DLINE_H horizontal \u2502 LINE_V vertical \u2551 DLINE_V vertical \u250c LINE_UR up right \u2554 DLINE_UR up right \u2510 LINE_UL up left \u2557 DLINE_UL up left \u2514 LINE_DR down right \u255a DLINE_DR down right \u2518 LINE_DL down left \u255d DLINE_DL down left \u2534 LINE_HU horizontal up \u2569 DLINE_HU horizontal up \u252c LINE_HD horizontal down \u2566 DLINE_HD horizontal down \u251c LINE_VR vertical right \u2560 DLINE_VR vertical right \u2524 LINE_VL vertical left \u2563 DLINE_VL vertical left \u253c LINE_HV crossed lines \u256c DLINE_HV crossed lines FILL_B blank space \u00ab ARROWS_L left arrows \u2591 FILL_L low dotted \u00bb ARROWS_R right arrows \u2592 FILL_M medium dotted \u2584 SQUARE_D square down \u2593 FILL_H highly dotted \u2580 SQUARE_U square up \u2588 FILL_F full filled \u25a0 SQUARE_M square middle","title":"Constants"},{"location":"wiki/cursor/#examples","text":"Following example writes colorful Hello world on screen with specified position. Cursor.setPosition(5,2); Cursor.setColor(YELLOW); std::cout << \"Hello world!\" << std::endl; These are examples show usage of colors. Window.setDefaultColor(MAGENTA, HEX(0xe0248c)); Cursor.setColor(MAGENTA, LIGHTCYAN); Cursor.printChar(12, 3, 'D', GREEN); Cursor.printChar(4, 9, FILL_F, GREEN); Window.setColor(CURRENT, WHITE); These are examples where usage of font. Cursor.setFontSize(22); Cursor.setFontType(L\"Lucida Console\"); std::cout << \"Printing some text\";","title":"Examples"},{"location":"wiki/cursor/#functions","text":"","title":"Functions"},{"location":"wiki/cursor/#bool-setpositionint-x-int-y","text":"This function sets the position of cursor. When you call any standard function to print a text, first character will be on the set position. Next characters will continue right and down. The cursor position will not change if given position is outside the console window. Parameters int x - position in columns int y - position in rows Return value Return type is bool . Return value is true if position was set successfully or position is outside the console window. Return value is false if unexpected error occurs. Example This example sets the cursor position to coordinates [12, 8] and writes there using C++ standard output, printf and putchar. Cursor.setPosition(12, 8); std::cout << \"Hello \"; printf(\"world\"); putchar('!');","title":"bool setPosition(int x, int y)"},{"location":"wiki/cursor/#bool-setcolorcolor-foreground-color-backgroundcurrent","text":"This function sets the color of cursor. It changes the foreground color of the printed characters and optionally you can also specify a background color. This function doesn't change already written characters (you can use Window.setColor() for that). Parameters Color - any color constant, foreground text color Color - (optional) any color, default is current background text color Return value Return type is bool . Return value is true if color was set successfully, false if any error occurs. Example This example writes two texts on the screen. First is a yellow text without specific background color, second is magenta text with light cyan background. Cursor.setColor(YELLOW); std::cout << \"Yellow text without background color\"; Cursor.setColor(MAGENTA, LIGHTCYAN); std::cout << \"Magenta text on light cyan background\";","title":"bool setColor(Color foreground, Color background=CURRENT)"},{"location":"wiki/cursor/#bool-setfontsizeint-size","text":"This function sets the height of characters in console. It calculates size proportionally to current console size. It is the most convenient and easy way to set the font size. Setting font size changes all text in console. Parameters int - new character height. Size 15 is approximately 1/50 of the console height. Return value Return type is bool . Return value is true if font was set successfully, false if any error occurs. Example This example writes a text on screen with size of 28. Then it waits for user input. After user presses a key, it resizes the console size and adjusts the font size to new console size. Cursor.setFontSize(28); std::cout << \"Press a key to change the screen size...\" << std::endl; Keyboard.waitUser(); Window.setSizePixels(1280,720); Cursor.setFontSize(28);","title":"bool setFontSize(int size)"},{"location":"wiki/cursor/#bool-setfontcharsint-columns-int-rows","text":"This function sets the font size in console. It calculates size proportionally to a given screen columns and rows. Setting font size changes all text in console. Parameters int - at most how many columns will font occupy int - at most how many rows will font occupy Return value Return type is bool . Return value is true if font was set successfully, false if any error occurs. Example This example sets the font to squares and writes a filled tic tac toe board. Window.setSizeChars(100, 50); Cursor.setFontChars(50, 50); std::cout << \"XOX\\nOXO\\nXOX\" << std::endl;","title":"bool setFontChars(int columns, int rows)"},{"location":"wiki/cursor/#bool-setfontpixelsint-width-int-height","text":"This function sets the font size in console. It sets the font equal to pixels. The result of this function depends heavily on console screen size in pixels. You probably should use pixel independent functions like setFontSize or setFontChars . Setting font size changes all text in console. Parameters int - width of font in pixels int - height of font in pixels Return value Return type is bool . Return value is true if font was set successfully, false if any error occurs. Example This example sets the font to Window.setSizeChars(100, 50); Cursor.setFontChars(50, 50); std::cout << \"XOX\\nOXO\\nXOX\" << std::endl;","title":"bool setFontPixels(int width, int height)"},{"location":"wiki/cursor/#bool-setfonttypewstring-name","text":"This function sets the font in console. The most common fonts are Consolas , Courier , Lucida Console , MS Gothic , Terminal . Setting font changes all text in console. More information about fonts is here . Parameters wstring - name of font as wide string. You can call this function without creating variable (see example) Return value Return type is bool . Return value is true if font was set successfully, false if any error occurs. Example This example sets the font to Lucida Console and then changes the font size. Notice that the wide string is created using L prefix. Cursor.setFontType(L\"Lucida Console\"); Cursor.setFontSize(28);","title":"bool setFontType(wstring name)"},{"location":"wiki/cursor/#bool-printcharint-x-int-y-int-character-color-colorcurrent","text":"This function prints one character on specified position. Additionally it can change a cursor color. To print a blank character you can use printBlank . To print more characters, use a setPosition and standard output. Parameters int - position in columns int - position in rows int - any character or Constant . Color - (optional) any Color constant, default is CURRENT Return value Return type is bool . Return value is true if everything works, false if any error occurs. If coordinates are outside screen it prints nothing and returns true . Example This is example writes a horizontal symbol on specified position. Then it writes W letter if W key was pressed and hides it after release. Cursor.printChar(3, 2, DLINE_V, LIGHTBLUE); if (Keyboard.getPressed('W')) { Cursor.printChar(11, 5, 'W'); } if (Keyboard.getReleased('W')) { Cursor.printBlank(11, 5); }","title":"bool printChar(int x, int y, int character, Color color=CURRENT)"},{"location":"wiki/cursor/#bool-printblankint-x-int-y","text":"This function prints blank character on specified position. To print a other characters you can use printChar . To print more characters, use a setPosition and standard output. Parameters int - position in columns int - position in rows Return value Return type is bool . Return value is true if everything works, false if any error occurs. If coordinates are outside screen it prints nothing and returns true . Example This is example creates a simple animation of X moving to right of the screen. for (int i = 1; i <= 16; i++) { Cursor.printChar(i, 0, 'X', LIGHTGREEN); Cursor.printBlank(i-1, 0); Keyboard.wait(30); }","title":"bool printBlank(int x, int y)"},{"location":"wiki/cursor/#bool-clearscreen","text":"This function fills entire console with blank characters. To hide only few characters you should use printBlank . This function is a replacement for overused system(\"cls\") . It is a more clean way to clear window. Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, false if any error occurs. Example This is example writes some text and then waits for user. After user presses a button, it clears the window. std::cout << \"Welcome in this awesome application.\"; Keyboard.waitUser(); Cursor.clearScreen(); std::cout << \"Do you want to show settings menu?\";","title":"bool clearScreen()"},{"location":"wiki/cursor/#int-getx","text":"This function gets x coordinate of cursor. After start of the console program, cursor is automatically set to the top left corner and is moved by printing text. You can use this function if you don't know cursor coordinates, for example in functions. The best strategy is to save the position in local variable instead of calling this function in every step. Parameters This function doesn't have any parameters. Return value Return type is int . Return value is column position of cursor. Example This example prints a Kryten quote and warns the programmer that they forget to put escape character in it. std::cout << \"I knew I was lying. No silicon heaven?\" std::cout << \"Preposterous! Where would all the calculators go?\"; if (Cursor.getX() > 80) { std::cout << std::endl << \"Line is too long, try adding \\\\n in it\"; }","title":"int getX()"},{"location":"wiki/cursor/#int-gety","text":"This function gets y coordinate of cursor. After start of the console program, cursor is automatically set to the top left corner and is moved by printing text. You can use this function if you don't know cursor coordinates, for example in functions. The best strategy is to save the position in local variable instead of calling this function in every step. Parameters This function doesn't have any parameters. Return value Return type is int . Return value is row position of cursor. Example This example prints a simple rectangle at cursor position. Notice that we do not need to print end of line characters. int cx = Cursor.getX(); int cy = Cursor.getY(); for (int y = cy; y < cy+5; y++) { Cursor.setPosition(cx, y); std::cout << \"~~~~~~\"; }","title":"int getY()"},{"location":"wiki/cursor/#color-getcolorforeground","text":"This function returns printing color of the cursor. LIGHTGRAY is usually the default color. To change color instead, use Cursor.setColor(). Parameters This function doesn't have any parameters. Return value Return type is Color . Return value is color constant. Only if error occurs, return value is CURRENT. Example This example writes text only if cursor color is light gray. if (Cursor.getColorForeground() == LIGHTGRAY) { std::cout << \"You are using gray cursor color.\"; }","title":"Color getColorForeground()"},{"location":"wiki/cursor/#color-getcolorbackground","text":"This function returns background printing color of the cursor. BLACK is usually the default color. To change color instead, use Cursor.setColor(). Parameters This function doesn't have any parameters. Return value Return type is Color . Return value is color constant. Only if error occurs, return value is CURRENT. Example This example changes background color for full console window to black. if (Cursor.getColorForeground() != BLACK) { Window.setColor(CURRENT, BLACK); }","title":"Color getColorBackground()"},{"location":"wiki/cursor/#int-getfontwidth","text":"This function returns pixel width of font . To get number of columns in console use Window.getColumns() instead. Parameters This function doesn't have any parameters. Return value Return type is int . Return value is width of cursor in pixels. Example This example writes font size ratio to console. double cursor_ratio = (double) Cursor.getFontWidth() / Cursor.getFontHeight(); std::cout << \"Ratio is \" << cursor_ratio;","title":"int getFontWidth()"},{"location":"wiki/cursor/#int-getfontheight","text":"This function returns pixel height of font . To get number of rows in console use Window.getRows() instead. Parameters This function doesn't have any parameters. Return value Return type is int . Return value is height of cursor in pixels. Example This example writes font size ratio to console. double scale = (double) 100 * Cursor.getFontHeight() / Window.getHeight(); std::cout << \"Your current scale is \" << scale;","title":"int getFontHeight()"},{"location":"wiki/cursor/#int-getfontsize","text":"This function returns unit height of font . The number can differ from last Cursor.setFontSize due to different console size and low integer precision. Parameters This function doesn't have any parameters. Return value Return type is int . Return value is size of cursor in pixels. Example This example sets the font to twice the size. int size = Cursor.getFontSize(); Cursor.getFontSize(size * 2); std::cout << \"Twice the power\";","title":"int getFontSize()"},{"location":"wiki/cursor/#wstring-getfonttype","text":"This function returns name of console font . Returned font is stored as wide string, meaning non English letters can be also returned. To print wide string use wcout instead of cout. Parameters This function doesn't have any parameters. Return value Return type is wstring . Return value is wide string containing console font name. Example This function sets console font to Terminal if it is not already in use. std::wstring family = Cursor.getFontType(); if (family != L\"Terminal\") { std::wcout << \"Changing font from \" << family << \" to Terminal.\"; Cursor.setFontType(L\"Terminal\"); }","title":"wstring getFontType()"},{"location":"wiki/keyboard/","text":"Keyboard Keyboard is used for getting input from user. It connects to keyboard and mouse keys. Keyboard has also some functions to slow the program in order to make it more user friendly. Table of Functions bool Keyboard.get(int key) bool Keyboard.getPressed(int key) bool Keyboard.getReleased(int key) bool Keyboard.wait(int ticks) bool Keyboard.waitUser() Information Keyboard keys are integer constants. You can use them as characters 'C' or use virtual keys . Virtual keys are used without quotations e. g. VK_RETURN . They are defined by windows and can be found at microsoft docs . The following table summarizes the most commonly used virtual keys. Virtual Key Description Virtual Key Description VK_LBUTTON Left mouse button VK_SPACE Spacebar VK_RBUTTON Right mouse button VK_SHIFT Shift key VK_MBUTTON Middle mouse button VK_CONTROL Control key VK_UP Up arrow key VK_MENU Alt key VK_LEFT Left arrow key VK_CAPITAL Caps Lock key VK_RIGHT Right arrow key VK_RETURN Enter key VK_DOWN Down arrow key VK_ESCAPE Escape key Following examples show basic usage of the keyboard object. if (Keyboard.getPressed(VK_UP)) // UP arrow was pressed while (Keyboard.get('A')) // While 'A' key is down if (Keyboard.getReleased('1')) // '1' key is released Keyboard.wait(30); // slows program to 30 FPS Functions bool Keyboard.get(int key) This function tests if a keyboard key is currently down. It outputs true as long as the key is down. You can use a Keyboard.wait() to slow down a while statement. Parameters int - any virtual key or character. Return value Return type is bool . Return value is true , when key is currently down. Otherwise is false . Example First example gets current input of 'W' key. The second example is while loop that loops until the spacebar is pressed. if (Keyboard.get('W')) { ... } while (!Keyboard.get(VK_SPACE)) { ... } bool Keyboard.getPressed(int key) This function checks if a key was pressed since the last call of Keyboard.wait() . Keyboard getPressed outputs true only once when key is pressed. Afterwards output becomes false regardless of the key state. To check current state of the keyboard use Keyboard.get() instead. Parameters int - any virtual key or character. Return value Return type is bool . Return value is true , once when the key is pressed. Otherwise is false . Example This function is useful when detecting single click on the mouse. Following code checks when mouse left button is pressed and then it prints a red 'X' on the mouse position using a Cursor. while(!Keyboard.get(VK_ESCAPE)) { if (Keyboard.getPressed(VK_LBUTTON)) { int mx = Mouse.getColumns(); int my = Mouse.getRows(); Cursor.printChar(mx,my,'X',LIGHTRED); } } bool Keyboard.getReleased(int key) This function checks if a key was released since the last call of Keyboard.wait() . Keyboard getReleased outputs true only once when key is released. Afterwards output becomes false regardless of the key state. To check current state of the keyboard use Keyboard.get() instead. Parameters int - any virtual key or character. Return value Return type is bool . Return value is true , once when the key is released. Otherwise is false . Example This function can be used when clicking on menu buttons. Only when a key button is released the desired action will be executed. User can change their mind in the last moment. In the following example a code checks if an ENTER key was pressed. Then it clears the console and based on a custom integer variable position chooses which action to take. if (Keyboard.getReleased(VK_RETURN)) { Cursor.clearScreen(); if (position == 1) std::cout<<\"Starting a new project\"; else if (position == 2) std::cout<<\"Loading a saved project\"; } bool Keyboard.wait(unsigned int ticks) This function slow downs program to specific number of ticks per second . It is also used for functions Keyboard.getPressed and Keyboard.getReleased . If you want to stop the program until user presses a key use Keyboard.waitUser() instead. This function should be used in while statements to slow down their fast repeats. Furthermore, this function should be the last function in the while statement. Parameters int - ticks per second that program should have. Passing a 0 doesn't stop program but will update keyboard functions. Return value Return type is bool . The output is true if all the functions were executed correctly. When error occurs return value is false . Example It can be used in games to slow down movement of player on the screen. It can also be used in menus to slow down fast scrolling using keyboard keys. This example changes x and y coordinates 30 times per second. while(!Keyboard.get(VK_ESCAPE)) { if (keyboard.getPressed(VK_LEFT)) { x -= 10; } if (keyboard.getPressed(VK_RIGHT)) { x += 10; } if (keyboard.getPressed(VK_UP)) { y -= 10; } if (keyboard.getPressed(VK_DOWN)) { y += 10; } Keyboard.wait(30); } bool Keyboard.waitUser() This function stops the application until user presses some button. Releasing a button doesn't trigger this function. If you want to slow down program to specific number of ticks per second use Keyboard.wait() instead. This function is used to stop a program from continuing until a user presses a button. Parameters This function doesn't have any parameters. Return value Return type is bool . The output is true if all the functions were executed correctly. When error occurs return value is false . Example Following example writes information on screen and waits until user presses any button. After pressing a button Cursor clears the screen. std::cout << \"That's all from the keyboard object!\" << std::endl; std::cout << \"Press any key to continue...\" << std::endl; Keyboard.waitUser(); Cursor.clearScreen();","title":"Keyboard"},{"location":"wiki/keyboard/#keyboard","text":"Keyboard is used for getting input from user. It connects to keyboard and mouse keys. Keyboard has also some functions to slow the program in order to make it more user friendly. Table of Functions bool Keyboard.get(int key) bool Keyboard.getPressed(int key) bool Keyboard.getReleased(int key) bool Keyboard.wait(int ticks) bool Keyboard.waitUser()","title":"Keyboard"},{"location":"wiki/keyboard/#information","text":"Keyboard keys are integer constants. You can use them as characters 'C' or use virtual keys . Virtual keys are used without quotations e. g. VK_RETURN . They are defined by windows and can be found at microsoft docs . The following table summarizes the most commonly used virtual keys. Virtual Key Description Virtual Key Description VK_LBUTTON Left mouse button VK_SPACE Spacebar VK_RBUTTON Right mouse button VK_SHIFT Shift key VK_MBUTTON Middle mouse button VK_CONTROL Control key VK_UP Up arrow key VK_MENU Alt key VK_LEFT Left arrow key VK_CAPITAL Caps Lock key VK_RIGHT Right arrow key VK_RETURN Enter key VK_DOWN Down arrow key VK_ESCAPE Escape key Following examples show basic usage of the keyboard object. if (Keyboard.getPressed(VK_UP)) // UP arrow was pressed while (Keyboard.get('A')) // While 'A' key is down if (Keyboard.getReleased('1')) // '1' key is released Keyboard.wait(30); // slows program to 30 FPS","title":"Information"},{"location":"wiki/keyboard/#functions","text":"","title":"Functions"},{"location":"wiki/keyboard/#bool-keyboardgetint-key","text":"This function tests if a keyboard key is currently down. It outputs true as long as the key is down. You can use a Keyboard.wait() to slow down a while statement. Parameters int - any virtual key or character. Return value Return type is bool . Return value is true , when key is currently down. Otherwise is false . Example First example gets current input of 'W' key. The second example is while loop that loops until the spacebar is pressed. if (Keyboard.get('W')) { ... } while (!Keyboard.get(VK_SPACE)) { ... }","title":"bool Keyboard.get(int key)"},{"location":"wiki/keyboard/#bool-keyboardgetpressedint-key","text":"This function checks if a key was pressed since the last call of Keyboard.wait() . Keyboard getPressed outputs true only once when key is pressed. Afterwards output becomes false regardless of the key state. To check current state of the keyboard use Keyboard.get() instead. Parameters int - any virtual key or character. Return value Return type is bool . Return value is true , once when the key is pressed. Otherwise is false . Example This function is useful when detecting single click on the mouse. Following code checks when mouse left button is pressed and then it prints a red 'X' on the mouse position using a Cursor. while(!Keyboard.get(VK_ESCAPE)) { if (Keyboard.getPressed(VK_LBUTTON)) { int mx = Mouse.getColumns(); int my = Mouse.getRows(); Cursor.printChar(mx,my,'X',LIGHTRED); } }","title":"bool Keyboard.getPressed(int key)"},{"location":"wiki/keyboard/#bool-keyboardgetreleasedint-key","text":"This function checks if a key was released since the last call of Keyboard.wait() . Keyboard getReleased outputs true only once when key is released. Afterwards output becomes false regardless of the key state. To check current state of the keyboard use Keyboard.get() instead. Parameters int - any virtual key or character. Return value Return type is bool . Return value is true , once when the key is released. Otherwise is false . Example This function can be used when clicking on menu buttons. Only when a key button is released the desired action will be executed. User can change their mind in the last moment. In the following example a code checks if an ENTER key was pressed. Then it clears the console and based on a custom integer variable position chooses which action to take. if (Keyboard.getReleased(VK_RETURN)) { Cursor.clearScreen(); if (position == 1) std::cout<<\"Starting a new project\"; else if (position == 2) std::cout<<\"Loading a saved project\"; }","title":"bool Keyboard.getReleased(int key)"},{"location":"wiki/keyboard/#bool-keyboardwaitunsigned-int-ticks","text":"This function slow downs program to specific number of ticks per second . It is also used for functions Keyboard.getPressed and Keyboard.getReleased . If you want to stop the program until user presses a key use Keyboard.waitUser() instead. This function should be used in while statements to slow down their fast repeats. Furthermore, this function should be the last function in the while statement. Parameters int - ticks per second that program should have. Passing a 0 doesn't stop program but will update keyboard functions. Return value Return type is bool . The output is true if all the functions were executed correctly. When error occurs return value is false . Example It can be used in games to slow down movement of player on the screen. It can also be used in menus to slow down fast scrolling using keyboard keys. This example changes x and y coordinates 30 times per second. while(!Keyboard.get(VK_ESCAPE)) { if (keyboard.getPressed(VK_LEFT)) { x -= 10; } if (keyboard.getPressed(VK_RIGHT)) { x += 10; } if (keyboard.getPressed(VK_UP)) { y -= 10; } if (keyboard.getPressed(VK_DOWN)) { y += 10; } Keyboard.wait(30); }","title":"bool Keyboard.wait(unsigned int ticks)"},{"location":"wiki/keyboard/#bool-keyboardwaituser","text":"This function stops the application until user presses some button. Releasing a button doesn't trigger this function. If you want to slow down program to specific number of ticks per second use Keyboard.wait() instead. This function is used to stop a program from continuing until a user presses a button. Parameters This function doesn't have any parameters. Return value Return type is bool . The output is true if all the functions were executed correctly. When error occurs return value is false . Example Following example writes information on screen and waits until user presses any button. After pressing a button Cursor clears the screen. std::cout << \"That's all from the keyboard object!\" << std::endl; std::cout << \"Press any key to continue...\" << std::endl; Keyboard.waitUser(); Cursor.clearScreen();","title":"bool Keyboard.waitUser()"},{"location":"wiki/mouse/","text":"Mouse Mouse object is used to get position of mouse in screen. Table of Functions bool Mouse.getX() bool Mouse.getX() bool Mouse.getColumns() bool Mouse.getRows() Information Mouse cursor position is in pixels. However this is not usually information you want when creating text interface. Therefore you can use handy function getRows and getColumns to get character position of mouse. Doing it this way, you can create applications and games that designed for any monitor screen size. SWTI Mouse is used only to detect position of mouse. To detect a mouse keys use keyboard object and virtual keys VK_LBUTTON , VK_RBUTTON and VK_MBUTTON . Mouse cursor is not the console cursor. You can not set mouse position. You can use mouse as following example. It is a simple drawing game. If left mouse button is pressed it writes on mouse character position letter M . Window.hideSelection(); while(!Keyboard.getPressed(VK_ESCAPE)) { int mx = Mouse.getColumns(); int my = Mouse.getRows(); if (Keyboard.get(VK_LBUTTON)) Cursor.printChar(mx, my, 'M', LIGHTBLUE); } Functions int Mouse.getX() This function returns relative position of mouse cursor in console window. The position is in pixels. The position in pixels changes depending on screen size and screen position. To get better result use Mouse.getColumns() . Function returns values from 0 to screen width . If mouse is outside the console window on the left, function returns negative numbers. When mouse is outside the console window on the right, function will return numbers larger than the screen width . Parameters This function doesn't have any parameters. Return value Return type is int . It is the X coordinate of mouse cursor in pixels relative to console window. Example This example writes simple sentence about the mouse cursor position in the window. std::cout << \"Mouse is in the \"; if (Mouse.getX() < 0) std::cout << \"left to the \"; if (Mouse.getX() > Window.getWidth()) std::cout << \"right to the \"; std::cout << \" window!\" << std::endl; int Mouse.getY() This function returns relative position of mouse cursor in console window. The position is in pixels. The position in pixels changes depending on screen size and screen position. To get better result use Mouse.getRows() . Function returns values from 0 to screen height . If mouse is outside the console window from above, function returns negative numbers. When mouse is outside the console window in the bottom, function will return numbers larger than the screen height . Parameters This function doesn't have any parameters. Return value Return type is int . It is the Y coordinate of mouse cursor in pixels relative to console window. Example This example writes simple sentence about the mouse cursor position in the window. std::cout << \"Mouse is in the \"; if (Mouse.getY() < 0) std::cout << \"above of the \"; if (Mouse.getY() > Window.getHeight()) std::cout << \"bottom of the \"; std::cout << \"window!\" << std::endl; int Mouse.getColumns() This function returns character position of mouse cursor in console window. The position is in columns. Columns are single characters in console. Using this function, you can easily determine position of mouse cursor on any device. Function returns values from 0 to screen columns . If mouse is outside the console window on the left, function returns negative numbers. When mouse is outside the console window on the right, function will return numbers larger than the screen columns . Parameters This function doesn't have any parameters. Return value Return type is int . It is the X coordinate of mouse cursor in characters. Example This example writes a symbol on screen and slowly moves it to the cursor. Put this example in a loop and define integer mpos to some arbitrary value. if (mpos < Mouse.getColumns()) {Cursor.printBlank(mpos, 10); mpos++; Cursor.printChar(mpos, 10, '~');} if (mpos > Mouse.getColumns()) {Cursor.printBlank(mpos, 10); mpos--; Cursor.printChar(mpos, 10, '~');} Keyboard.wait(30); int Mouse.getRows() This function returns character position of mouse cursor in console window. The position is in rows. Rows are single characters in console. Using this function, you can easily determine position of mouse cursor on any device. Function returns values from 0 to screen rows . If mouse is outside the console window from above, function returns negative numbers. When mouse is outside the console window in the bottom, function will return numbers larger than the screen rows . Parameters This function doesn't have any parameters. Return value Return type is int . It is the Y coordinate of mouse cursor in characters. Example This example is easy way how to highlight menu option. You put following code in a loop since it doesn't rewrite text each frame, but only when necessary. Do not forget to set integer variable lastposition . if (lastposition != Mouse.getRows()) { Cursor.setPosition(10, 2); if (Mouse.getRows() == 2) Cursor.setColor(LIGHTGREEN); else Cursor.setColor(WHITE); std::cout << \"Start the game\"; } lastposition = Mouse.getRows(); Keyboard.wait(30);","title":"Mouse"},{"location":"wiki/mouse/#mouse","text":"Mouse object is used to get position of mouse in screen. Table of Functions bool Mouse.getX() bool Mouse.getX() bool Mouse.getColumns() bool Mouse.getRows()","title":"Mouse"},{"location":"wiki/mouse/#information","text":"Mouse cursor position is in pixels. However this is not usually information you want when creating text interface. Therefore you can use handy function getRows and getColumns to get character position of mouse. Doing it this way, you can create applications and games that designed for any monitor screen size. SWTI Mouse is used only to detect position of mouse. To detect a mouse keys use keyboard object and virtual keys VK_LBUTTON , VK_RBUTTON and VK_MBUTTON . Mouse cursor is not the console cursor. You can not set mouse position. You can use mouse as following example. It is a simple drawing game. If left mouse button is pressed it writes on mouse character position letter M . Window.hideSelection(); while(!Keyboard.getPressed(VK_ESCAPE)) { int mx = Mouse.getColumns(); int my = Mouse.getRows(); if (Keyboard.get(VK_LBUTTON)) Cursor.printChar(mx, my, 'M', LIGHTBLUE); }","title":"Information"},{"location":"wiki/mouse/#functions","text":"","title":"Functions"},{"location":"wiki/mouse/#int-mousegetx","text":"This function returns relative position of mouse cursor in console window. The position is in pixels. The position in pixels changes depending on screen size and screen position. To get better result use Mouse.getColumns() . Function returns values from 0 to screen width . If mouse is outside the console window on the left, function returns negative numbers. When mouse is outside the console window on the right, function will return numbers larger than the screen width . Parameters This function doesn't have any parameters. Return value Return type is int . It is the X coordinate of mouse cursor in pixels relative to console window. Example This example writes simple sentence about the mouse cursor position in the window. std::cout << \"Mouse is in the \"; if (Mouse.getX() < 0) std::cout << \"left to the \"; if (Mouse.getX() > Window.getWidth()) std::cout << \"right to the \"; std::cout << \" window!\" << std::endl;","title":"int Mouse.getX()"},{"location":"wiki/mouse/#int-mousegety","text":"This function returns relative position of mouse cursor in console window. The position is in pixels. The position in pixels changes depending on screen size and screen position. To get better result use Mouse.getRows() . Function returns values from 0 to screen height . If mouse is outside the console window from above, function returns negative numbers. When mouse is outside the console window in the bottom, function will return numbers larger than the screen height . Parameters This function doesn't have any parameters. Return value Return type is int . It is the Y coordinate of mouse cursor in pixels relative to console window. Example This example writes simple sentence about the mouse cursor position in the window. std::cout << \"Mouse is in the \"; if (Mouse.getY() < 0) std::cout << \"above of the \"; if (Mouse.getY() > Window.getHeight()) std::cout << \"bottom of the \"; std::cout << \"window!\" << std::endl;","title":"int Mouse.getY()"},{"location":"wiki/mouse/#int-mousegetcolumns","text":"This function returns character position of mouse cursor in console window. The position is in columns. Columns are single characters in console. Using this function, you can easily determine position of mouse cursor on any device. Function returns values from 0 to screen columns . If mouse is outside the console window on the left, function returns negative numbers. When mouse is outside the console window on the right, function will return numbers larger than the screen columns . Parameters This function doesn't have any parameters. Return value Return type is int . It is the X coordinate of mouse cursor in characters. Example This example writes a symbol on screen and slowly moves it to the cursor. Put this example in a loop and define integer mpos to some arbitrary value. if (mpos < Mouse.getColumns()) {Cursor.printBlank(mpos, 10); mpos++; Cursor.printChar(mpos, 10, '~');} if (mpos > Mouse.getColumns()) {Cursor.printBlank(mpos, 10); mpos--; Cursor.printChar(mpos, 10, '~');} Keyboard.wait(30);","title":"int Mouse.getColumns()"},{"location":"wiki/mouse/#int-mousegetrows","text":"This function returns character position of mouse cursor in console window. The position is in rows. Rows are single characters in console. Using this function, you can easily determine position of mouse cursor on any device. Function returns values from 0 to screen rows . If mouse is outside the console window from above, function returns negative numbers. When mouse is outside the console window in the bottom, function will return numbers larger than the screen rows . Parameters This function doesn't have any parameters. Return value Return type is int . It is the Y coordinate of mouse cursor in characters. Example This example is easy way how to highlight menu option. You put following code in a loop since it doesn't rewrite text each frame, but only when necessary. Do not forget to set integer variable lastposition . if (lastposition != Mouse.getRows()) { Cursor.setPosition(10, 2); if (Mouse.getRows() == 2) Cursor.setColor(LIGHTGREEN); else Cursor.setColor(WHITE); std::cout << \"Start the game\"; } lastposition = Mouse.getRows(); Keyboard.wait(30);","title":"int Mouse.getRows()"},{"location":"wiki/window/","text":"Window Window object is used to get and set console window size and its properties. Table of Set functions bool setSizeChars(int columns, int rows) bool setSizePixels(int width, int height) bool setPositionPixels(int x, int y) bool setPositionCenter() bool setFullscreenWindow() bool setFullscreenBorderless() bool setColor(Color foreground, Color background) bool setDefaultColor(Color color, int value) bool setTitle(wstring title) Table of Show functions bool showBlinking() bool hideBlinking() bool showSelection() bool hideSelection() bool showScrollbars(int columns, int rows) bool hideScrollbars() Table of Get functions int getX() int getY() int getWidth() int getHeight() int getColumns() int getRows() int getScreenWidth() int getScreenHeight() int getBarHeight() int getTitle() int getDefaultColor(Color color) Information The difference between a console window or simply console and screen is very important. Console is an application used to run commands and executable files. Screen is the full size of working area on monitor. The position and size of console window can be changed by user or by code itself. You can use functions below to get and set these properties exactly. The console window and screen size are different for each user . When publishing an application you should account for these different screen sizes. The easiest solution is to use Window.setFullscreenBorderless and Cursor.setFontChars . The first function sets the console size to match the screen size and the second function adjusts cursor font to a given number of characters in columns and rows. For getting mouse position, use Mouse.getRows and Mouse.getCollumns instead of raw pixels. Character size When working inside a console, the most important functions are Window.getRows and Window.getColumns . You can use these functions to determine exact number of characters you can write to console. You also can set these using Window.setSizeChars . Pixel size When working with raw pixels, following six functions can be used. Functions getX and getY retrieve position of top left corner of the console window in pixels. You also can set the position with Window.setPositionCenter or Window.setPositionPixels . Window width and height in pixels are obtained using getWidth and getHeight . For resizing window in pixels you can use setSizePixels . Finally, monitor screen size can be obtained using getScreenWidth and getScreenHeight . Window can be used as following example. Window.setFullscreenBorderless(); middle = Window.getColumns() / 2; center = Window.getRows() / 2; Functions bool setSizeChars(int columns, int rows) This function sets the console window size to specified number of characters. The result depends on font size. To set the window size to fullscreen use setFullscreenWindow or setFullscreenBorderless instead. Parameters int - number of columns resized console will have rows - number of rows resized console will have Return value Return type is bool . Return value is true if everything works, else false . Setting size to low number of characters can throw an error, because the window is too small to draw navigation pane. One solution is to set higher font size . Example This example sets screen size to only 9 chars and prints a simple frame. Cursor.setFontPixels(30, 30); Window.setSizeChars(9, 9); Cursor.printChar(7, 7, 'X'); Cursor.printChar(1, 1, 'X'); Cursor.printChar(1, 7, 'X'); Cursor.printChar(7, 1, 'X'); bool setSizePixels(int width, int height) This function sets the console window size to specified pixels. Window is automatically aligned to center. Trailing characters are shown on the next lines. For new console information use getColumns and getRows . To set the window size to fullscreen use setFullscreenWindow or setFullscreenBorderless instead. Parameters int - height of new window in pixels int - width of new window in pixels Return value Return type is bool . Return value is true if everything works, else false . Example This example changes the window size three times and waits for user input after each one. Window.setSizePixels(640, 480); Keyboard.waitUser(); Window.setSizePixels(1024, 720); Keyboard.waitUser(); Window.setSizePixels(1920, 1080); Keyboard.waitUser(); bool setPositionPixels(int x, int y) This function sets the position of console window in pixels. If you want to set window position to center you can use setPositionCenter Parameters int - x pixel position of window int - y pixel position of window Return value Return type is bool . Return value is true if everything works, else false . Example This example sets the position of the window to left top third of the screen. int xpos = Window.getScreenWidth()/3 - Window.getWidth()/2; int ypos = Window.getScreenHeight()/3 - Window.getHeight()/2; Window.setPositionPixels(xpos, ypos); bool setPositionCenter() This function sets position of console window to the center of the screen. This function is called automatically after Window.setSizePixels and Window.setSizeChars . Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, else false . Example This example sets the position of the window to center and creates a loading bar. Window.setPositionCenter(); std::cout << \"Retrieving information\" << std::endl; for(int i = 0; i <= 21; i++) { std::cout << '.'; Keyboard.wait(30); } bool setFullscreenWindow() This function sets the console size to maximum. This function doesn't hide borders, top navigation panel is still visible and also the bottom application pane. If you want to fill with console to entire fullscreen, use setFullscreenBorderless Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, else false . Example This example resizes the window and writes three crosses in the bottom of the console. Window.setFullscreenWindow(); int middle = Window.getColumns() / 2 - 6; int bottom = Window.getRows() - 1; Cursor.setPosition(middle, bottom); std::cout << \"-x- -x- -x-\"; bool setFullscreenBorderless() This function fills the entire screen with the console size. This function hides top navigation panel and bottom application pane. This function is designed for full scale applications and games. If you want to set the console back to window use the function again or use setFullscreenWindow . Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, else false . Example This example asks the user, if they . std::string answer; std::cout << \"Do you want to set the console to fullscreen? \"; std::cin >> answer; if (answer == \"Yes\") { std::cout << \"Console was set to fullscreen. \"; Window.setFullscreenBorderless(); } bool setColor(Color foreground, Color background) This function will fill whole window with two colors. You specify the foreground color and background color. If you want to clear all text use clearScreen . Parameters Color any color constant, text foreground color Color any color constant, text background color Return value Return type is bool . Return value is true if everything works, else false . Example This example sets the console colors as a preferred theme. std::string theme = \"blue\"; if (theme == \"blue\") Window.setColor(WHITE, BLUE); else if (theme == \"green\") Window.setColor(LIGHTYELLOW, GREEN); std::cout << \"Menu Window\" << std::endl; bool setDefaultColor(Color color, int value) This function sets the default colors for console. Each console has 16 distinct colors which you can change. Setting BLACK color sets the window background. Setting WHITE sets the default white text color. Parameters Color color constant value integer color value, best used with RGB macro or HEX function (see example). Return value Return type is bool . Return value is true if everything works, else false . false is also returned if integer color is in wrong format or unknown color. Example This example flips colors of console. Background will be white and black text. Window.setDefaultColor(BLACK, HEX(0xFCFAF0)); Window.setDefaultColor(WHITE, RGB(72, 77, 87)); std::cout << \"Hello new world!\"; bool setTitle(wstring title) This function sets the name of the console. The text is written in console header. Function does not change the given string, meaning you can call this function without creating a string variable. Parameters wstring wide string from standard library used as a constant. Return value Return type is bool . Return value is true if everything works, else false . Example This example sets window color and title, and writes a simple text to console. Window.setColor(WHITE, CYAN); Window.setTitle(L\"RockOS\"); Window.hideScrollbars(); Cursor.setFontSize(30); std::cout << \"Welcome in RockOS!\" << std::endl; bool showBlinking() This function shows the blinking animation on cursor position when waiting for user input. It is useful when waiting for user input. It is set by default and resets after resizing the window. Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, else false . Example This example asks the user for their name and then writes to screen. using namespace std; string name; Window.showBlinking(); cout << \"What is your name? \"; cin >> name; cout << \"Hello \" << name << \"!\"; bool hideBlinking() This function hides the blinking animation on cursor position when waiting for user input. It is useful when making games. Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, else false . Example This example flies a dragon across the console window. Notice one blank character in the cout. Window.hideBlinking(); int x = 0; while(true) { std::cout << \" Dragon\"; Cursor.setPosition(x++,0); Keyboard.wait(5); } bool showSelection() This function enables the selection in console application. Selecting text pauses the console application. It is useful when writing an important data for user. It is set by default. Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, else false . Example This example writes a random code to screen and asks the user to copy it. #include <stdlib.h> Window.showSelection(); std::cout << \"Please copy this code: \"; for (int i = 0; i < 16; i++) std::cout << (char) ('A' + rand() % ('Z' - 'A' + 1)); bool hideSelection() This function enables the selection in console application. Selecting text pauses the console application. It is useful when writing an important data for user. It is set by default. Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, else false . Example This example writes text and then waits until user releases left mouse button. Without hideSelection this example would not work correctly. Window.hideSelection(); std::cout << \"== | Start the game | == \" << std::endl; while(!Keyboard.getReleased(VK_LBUTTON)) Keyboard.wait(30); std::cout << \"Loading the scenes ...\"; bool showScrollbars(int columns, int rows) This function shows the scrollbars in console and sets their size. It also resizes the console buffer meaning you can write more or less text in console. Setting one parameter to zero hides corresponding scrollbar. Parameters int - number of horizontal characters int - number of vertical characters Return value Return type is bool . Return value is true if everything works, else false . Example This example writes list of squared numbers. Window.setSizeChars(80, 20); Window.showScrollbars(0, 50); for(int i = 0; i <= 50; i++) std::cout << i << \":\\t\" << i * i << std::endl; bool hideScrollbars() This function hides the scrollbars in console. It also removes all characters that are out of bounds. Due to this fact, it is recommended to stay in one console screen and not to write large texts at once. Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, else false . Example This example prints out a circle out of 'o' characters. Hiding scrollbars isn't necessary, but picture is cleaner. Window.hideScrollbars(); int x = 0, y = 0; for(int i = -10; i <= 10; i++) for(int j = -10; j <= 10; j++) if (i * i + j * j < 80) Cursor.printChar(10 + i, 10 + j, 'o'); bool showResize() This function shows the manual resize option. It enables user to set console size. User can drag borders of console to set size or use maximize option in top right corner. Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, else false . Example This example writes 100 random numbers. User can resize the window to better distinguish them. Window.showResize(); std::cout << \"Information: \"; for (int i = 0; i < 100; i++) std::cout << rand() << \", \"; bool hideResize() This function disables manual resize option. It prevents user to set console size. Changing console size can be done only using commands. Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, else false . Example This example resizes window to square and disables resizing and scrolling. It can be used in games like snake. int screen_height = Window.getScreenHeight(); Window.setSizePixels(screen_height/2, screen_height/2); Window.hideScrollbars(); Window.hideResize(); int getX() This function returns left coordinate of the window in pixels. It is the left most coordinate of working area. You can use Window.setPositionPixels or Window.setPositionCenter to set position of window using a code. Parameters This function doesn't have any parameters. Return value Return type is int . Return value is x pixel position of top left corner. Example This example prints a sword pointing in direction of mouse. if (Mouse.getX() < Window.getX()) std::cout << \"<;;;;;;;;;]xxxxx(\"; else std::cout << \")xxxxx[;;;;;;;;;>\"; int getY() This function returns top coordinate of the window in pixels. It returns position of top corner of working area, without height of navigation bar. You can use getBarHeight to manually adjust coordinate to your needs. You can use Window.setPositionPixels or Window.setPositionCenter to set position of window using a code. Parameters This function doesn't have any parameters. Return value Return type is int . Return value is y pixel position of top left corner. Example This example sets console position to center if console is outside the screen. if (Window.getY() + Window.getHeight() > Window.getScreenHeight()) Window.setPositionCenter(); int getWidth() This function returns width of the window in pixels. When calculating position of right corner of window use sum of Window.getX() and Window.getWidth() . Parameters This function doesn't have any parameters. Return value Return type is int . Return value is size in x of the window. Example This example sets the console size if console is too small. int size = Window.getScreenWidth() / 2; if (Window.getWidth() < size) Window.setSizePixels(size, Window.getScreenHeight()/2); int getHeight() This function returns height of the window in pixels. When calculating position of bottom corner of window use sum of Window.getX() and Window.getHeight() . Parameters This function doesn't have any parameters. Return value Return type is int . Return value is size in y of the window. Example This example sets the screen size to match ratio of 16 : 9. int wh = Window.getHeight(); int ww = (16 * wh) / 9; Window.setSizePixels(ww, wh); int getColumns() This function returns size of the window in columns. It is used when writing text to middle of the screen or to its corners. You can set window size in columns and rows using Window.setSizeChars() . Parameters This function doesn't have any parameters. Return value Return type is int . Return value is number of columns of the window. Example This example writes text in the middle of console width. std::string text = \"Start the application\"; int pos = Window.getColumns()/2 - text.length()/2 -1; Cursor.setPosition(pos, 0); std::cout << text; int getRows() This function returns size of the window in rows. It is used when writing text to middle of the screen or to its corners. You can set window size in columns and rows using Window.setSizeChars() . Parameters This function doesn't have any parameters. Return value Return type is int . Return value is number of rows of the window. Example This example writes a simple cross across the screen. int x = 0, rows = Window.getRows(), max = 2 * rows - 2; for(int y = 0; y < rows; y++) { Cursor.setPosition(x, y); std::cout << \"XXX\"; Cursor.setPosition(max - x, y); std::cout << \"XXX\"; x += 2; } int getScreenWidth() This function returns width of the screen in pixels. If you want to set window position to center use Window.setPositionCenter() . Parameters This function doesn't have any parameters. Return value Return type is int . Return value is width of the screen in pixels. Example This example resizes the console size to the half of screen size. int screen_width = Window.getScreenWidth(); int screen_height = Window.getScreenHeight(); Window.setSizePixels(screen_width/2, screen_height/2); int getScreenHeight() This function returns height of the screen in pixels. It is the size of working area. You can use getBarHeight to add height of navigation bar. If you want to set window position to center use Window.setPositionCenter() . Parameters This function doesn't have any parameters. Return value Return type is int . Return value is height of the screen in pixels. Example This prints screen ratio. It uses greatest common devisor ( gcd ) from numberic, but you can write your own. #include <numeric> int width = Window.getScreenWidth(); int height = Window.getScreenHeight(); int greatest = std::gcd(width, height); std::cout << \"Your ratio is \" << width/greatest << \" : \" << height/greatest; int getBarHeight() This function returns height of the title bar in pixels. With this function you can determine if you are in fullscreen mode. If you want to make interactive application use Mouse.getX and Mouse.getY . Parameters This function doesn't have any parameters. Return value Return type is int . Return value is approximated height of the window title bar in pixels. Example This example asks user to hold Y key to set console to borderless mode. Then it writes a simple message. Keep in mind that the second if statement is not necessary in this small example and code can rewritten without it. std::cout << \"Hold Y to set window to borderless mode.\" << std::endl; Keyboard.waitUser(); if (Keyboard.get('Y')) Window.setFullscreenBorderless(); if (!Window.getBarHeight()) std::cout << \"You are in borderless fullscreen mode.\"; wstring getTitle() This function gets the name of the console. The text is written in console header. Parameters This function doesn't have any parameters. Return value wstring wide string from standard library used as a constant. Example This example gets window title and writes it to screen using wcout. Cursor.setColor(WHITE); std::wcout << \"You are running from a \"; Cursor.setColor(LIGHTGRAY); std::wcout << Window.getTitle(); Cursor.setColor(WHITE); std::wcout << \" console.\"; int getDefaultColor(Color color) This function get HEX value of default color from console palette. You need to specify which color you want to return. Parameters Color color from palette Return value Return type is int . Return value is numerical representation of color. You can print it using std::hex tag. Example This example prints rgb values of green color and hex value of black color. #include <iostream> #include <iomanip> #include \"swti/swti.hpp\" int main() { int green = Window.getDefaultColor(GREEN); int black = Window.getDefaultColor(BLACK); std::cout << \"Green in rgb is (\" << GET_RED(green) << \", \" << GET_GREEN(green) << \", \" << GET_BLUE(green) << \").\\n\"; std::cout << \"Black in hex is \" << std::setw(6) << std::setfill('0') << std::hex << black << \".\\n\"; return 0; }","title":"Window"},{"location":"wiki/window/#window","text":"Window object is used to get and set console window size and its properties. Table of Set functions bool setSizeChars(int columns, int rows) bool setSizePixels(int width, int height) bool setPositionPixels(int x, int y) bool setPositionCenter() bool setFullscreenWindow() bool setFullscreenBorderless() bool setColor(Color foreground, Color background) bool setDefaultColor(Color color, int value) bool setTitle(wstring title) Table of Show functions bool showBlinking() bool hideBlinking() bool showSelection() bool hideSelection() bool showScrollbars(int columns, int rows) bool hideScrollbars() Table of Get functions int getX() int getY() int getWidth() int getHeight() int getColumns() int getRows() int getScreenWidth() int getScreenHeight() int getBarHeight() int getTitle() int getDefaultColor(Color color)","title":"Window"},{"location":"wiki/window/#information","text":"The difference between a console window or simply console and screen is very important. Console is an application used to run commands and executable files. Screen is the full size of working area on monitor. The position and size of console window can be changed by user or by code itself. You can use functions below to get and set these properties exactly. The console window and screen size are different for each user . When publishing an application you should account for these different screen sizes. The easiest solution is to use Window.setFullscreenBorderless and Cursor.setFontChars . The first function sets the console size to match the screen size and the second function adjusts cursor font to a given number of characters in columns and rows. For getting mouse position, use Mouse.getRows and Mouse.getCollumns instead of raw pixels.","title":"Information"},{"location":"wiki/window/#character-size","text":"When working inside a console, the most important functions are Window.getRows and Window.getColumns . You can use these functions to determine exact number of characters you can write to console. You also can set these using Window.setSizeChars .","title":"Character size"},{"location":"wiki/window/#pixel-size","text":"When working with raw pixels, following six functions can be used. Functions getX and getY retrieve position of top left corner of the console window in pixels. You also can set the position with Window.setPositionCenter or Window.setPositionPixels . Window width and height in pixels are obtained using getWidth and getHeight . For resizing window in pixels you can use setSizePixels . Finally, monitor screen size can be obtained using getScreenWidth and getScreenHeight . Window can be used as following example. Window.setFullscreenBorderless(); middle = Window.getColumns() / 2; center = Window.getRows() / 2;","title":"Pixel size"},{"location":"wiki/window/#functions","text":"","title":"Functions"},{"location":"wiki/window/#bool-setsizecharsint-columns-int-rows","text":"This function sets the console window size to specified number of characters. The result depends on font size. To set the window size to fullscreen use setFullscreenWindow or setFullscreenBorderless instead. Parameters int - number of columns resized console will have rows - number of rows resized console will have Return value Return type is bool . Return value is true if everything works, else false . Setting size to low number of characters can throw an error, because the window is too small to draw navigation pane. One solution is to set higher font size . Example This example sets screen size to only 9 chars and prints a simple frame. Cursor.setFontPixels(30, 30); Window.setSizeChars(9, 9); Cursor.printChar(7, 7, 'X'); Cursor.printChar(1, 1, 'X'); Cursor.printChar(1, 7, 'X'); Cursor.printChar(7, 1, 'X');","title":"bool setSizeChars(int columns, int rows)"},{"location":"wiki/window/#bool-setsizepixelsint-width-int-height","text":"This function sets the console window size to specified pixels. Window is automatically aligned to center. Trailing characters are shown on the next lines. For new console information use getColumns and getRows . To set the window size to fullscreen use setFullscreenWindow or setFullscreenBorderless instead. Parameters int - height of new window in pixels int - width of new window in pixels Return value Return type is bool . Return value is true if everything works, else false . Example This example changes the window size three times and waits for user input after each one. Window.setSizePixels(640, 480); Keyboard.waitUser(); Window.setSizePixels(1024, 720); Keyboard.waitUser(); Window.setSizePixels(1920, 1080); Keyboard.waitUser();","title":"bool setSizePixels(int width, int height)"},{"location":"wiki/window/#bool-setpositionpixelsint-x-int-y","text":"This function sets the position of console window in pixels. If you want to set window position to center you can use setPositionCenter Parameters int - x pixel position of window int - y pixel position of window Return value Return type is bool . Return value is true if everything works, else false . Example This example sets the position of the window to left top third of the screen. int xpos = Window.getScreenWidth()/3 - Window.getWidth()/2; int ypos = Window.getScreenHeight()/3 - Window.getHeight()/2; Window.setPositionPixels(xpos, ypos);","title":"bool setPositionPixels(int x, int y)"},{"location":"wiki/window/#bool-setpositioncenter","text":"This function sets position of console window to the center of the screen. This function is called automatically after Window.setSizePixels and Window.setSizeChars . Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, else false . Example This example sets the position of the window to center and creates a loading bar. Window.setPositionCenter(); std::cout << \"Retrieving information\" << std::endl; for(int i = 0; i <= 21; i++) { std::cout << '.'; Keyboard.wait(30); }","title":"bool setPositionCenter()"},{"location":"wiki/window/#bool-setfullscreenwindow","text":"This function sets the console size to maximum. This function doesn't hide borders, top navigation panel is still visible and also the bottom application pane. If you want to fill with console to entire fullscreen, use setFullscreenBorderless Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, else false . Example This example resizes the window and writes three crosses in the bottom of the console. Window.setFullscreenWindow(); int middle = Window.getColumns() / 2 - 6; int bottom = Window.getRows() - 1; Cursor.setPosition(middle, bottom); std::cout << \"-x- -x- -x-\";","title":"bool setFullscreenWindow()"},{"location":"wiki/window/#bool-setfullscreenborderless","text":"This function fills the entire screen with the console size. This function hides top navigation panel and bottom application pane. This function is designed for full scale applications and games. If you want to set the console back to window use the function again or use setFullscreenWindow . Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, else false . Example This example asks the user, if they . std::string answer; std::cout << \"Do you want to set the console to fullscreen? \"; std::cin >> answer; if (answer == \"Yes\") { std::cout << \"Console was set to fullscreen. \"; Window.setFullscreenBorderless(); }","title":"bool setFullscreenBorderless()"},{"location":"wiki/window/#bool-setcolorcolor-foreground-color-background","text":"This function will fill whole window with two colors. You specify the foreground color and background color. If you want to clear all text use clearScreen . Parameters Color any color constant, text foreground color Color any color constant, text background color Return value Return type is bool . Return value is true if everything works, else false . Example This example sets the console colors as a preferred theme. std::string theme = \"blue\"; if (theme == \"blue\") Window.setColor(WHITE, BLUE); else if (theme == \"green\") Window.setColor(LIGHTYELLOW, GREEN); std::cout << \"Menu Window\" << std::endl;","title":"bool setColor(Color foreground, Color background)"},{"location":"wiki/window/#bool-setdefaultcolorcolor-color-int-value","text":"This function sets the default colors for console. Each console has 16 distinct colors which you can change. Setting BLACK color sets the window background. Setting WHITE sets the default white text color. Parameters Color color constant value integer color value, best used with RGB macro or HEX function (see example). Return value Return type is bool . Return value is true if everything works, else false . false is also returned if integer color is in wrong format or unknown color. Example This example flips colors of console. Background will be white and black text. Window.setDefaultColor(BLACK, HEX(0xFCFAF0)); Window.setDefaultColor(WHITE, RGB(72, 77, 87)); std::cout << \"Hello new world!\";","title":"bool setDefaultColor(Color color, int value)"},{"location":"wiki/window/#bool-settitlewstring-title","text":"This function sets the name of the console. The text is written in console header. Function does not change the given string, meaning you can call this function without creating a string variable. Parameters wstring wide string from standard library used as a constant. Return value Return type is bool . Return value is true if everything works, else false . Example This example sets window color and title, and writes a simple text to console. Window.setColor(WHITE, CYAN); Window.setTitle(L\"RockOS\"); Window.hideScrollbars(); Cursor.setFontSize(30); std::cout << \"Welcome in RockOS!\" << std::endl;","title":"bool setTitle(wstring title)"},{"location":"wiki/window/#bool-showblinking","text":"This function shows the blinking animation on cursor position when waiting for user input. It is useful when waiting for user input. It is set by default and resets after resizing the window. Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, else false . Example This example asks the user for their name and then writes to screen. using namespace std; string name; Window.showBlinking(); cout << \"What is your name? \"; cin >> name; cout << \"Hello \" << name << \"!\";","title":"bool showBlinking()"},{"location":"wiki/window/#bool-hideblinking","text":"This function hides the blinking animation on cursor position when waiting for user input. It is useful when making games. Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, else false . Example This example flies a dragon across the console window. Notice one blank character in the cout. Window.hideBlinking(); int x = 0; while(true) { std::cout << \" Dragon\"; Cursor.setPosition(x++,0); Keyboard.wait(5); }","title":"bool hideBlinking()"},{"location":"wiki/window/#bool-showselection","text":"This function enables the selection in console application. Selecting text pauses the console application. It is useful when writing an important data for user. It is set by default. Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, else false . Example This example writes a random code to screen and asks the user to copy it. #include <stdlib.h> Window.showSelection(); std::cout << \"Please copy this code: \"; for (int i = 0; i < 16; i++) std::cout << (char) ('A' + rand() % ('Z' - 'A' + 1));","title":"bool showSelection()"},{"location":"wiki/window/#bool-hideselection","text":"This function enables the selection in console application. Selecting text pauses the console application. It is useful when writing an important data for user. It is set by default. Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, else false . Example This example writes text and then waits until user releases left mouse button. Without hideSelection this example would not work correctly. Window.hideSelection(); std::cout << \"== | Start the game | == \" << std::endl; while(!Keyboard.getReleased(VK_LBUTTON)) Keyboard.wait(30); std::cout << \"Loading the scenes ...\";","title":"bool hideSelection()"},{"location":"wiki/window/#bool-showscrollbarsint-columns-int-rows","text":"This function shows the scrollbars in console and sets their size. It also resizes the console buffer meaning you can write more or less text in console. Setting one parameter to zero hides corresponding scrollbar. Parameters int - number of horizontal characters int - number of vertical characters Return value Return type is bool . Return value is true if everything works, else false . Example This example writes list of squared numbers. Window.setSizeChars(80, 20); Window.showScrollbars(0, 50); for(int i = 0; i <= 50; i++) std::cout << i << \":\\t\" << i * i << std::endl;","title":"bool showScrollbars(int columns, int rows)"},{"location":"wiki/window/#bool-hidescrollbars","text":"This function hides the scrollbars in console. It also removes all characters that are out of bounds. Due to this fact, it is recommended to stay in one console screen and not to write large texts at once. Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, else false . Example This example prints out a circle out of 'o' characters. Hiding scrollbars isn't necessary, but picture is cleaner. Window.hideScrollbars(); int x = 0, y = 0; for(int i = -10; i <= 10; i++) for(int j = -10; j <= 10; j++) if (i * i + j * j < 80) Cursor.printChar(10 + i, 10 + j, 'o');","title":"bool hideScrollbars()"},{"location":"wiki/window/#bool-showresize","text":"This function shows the manual resize option. It enables user to set console size. User can drag borders of console to set size or use maximize option in top right corner. Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, else false . Example This example writes 100 random numbers. User can resize the window to better distinguish them. Window.showResize(); std::cout << \"Information: \"; for (int i = 0; i < 100; i++) std::cout << rand() << \", \";","title":"bool showResize()"},{"location":"wiki/window/#bool-hideresize","text":"This function disables manual resize option. It prevents user to set console size. Changing console size can be done only using commands. Parameters This function doesn't have any parameters. Return value Return type is bool . Return value is true if everything works, else false . Example This example resizes window to square and disables resizing and scrolling. It can be used in games like snake. int screen_height = Window.getScreenHeight(); Window.setSizePixels(screen_height/2, screen_height/2); Window.hideScrollbars(); Window.hideResize();","title":"bool hideResize()"},{"location":"wiki/window/#int-getx","text":"This function returns left coordinate of the window in pixels. It is the left most coordinate of working area. You can use Window.setPositionPixels or Window.setPositionCenter to set position of window using a code. Parameters This function doesn't have any parameters. Return value Return type is int . Return value is x pixel position of top left corner. Example This example prints a sword pointing in direction of mouse. if (Mouse.getX() < Window.getX()) std::cout << \"<;;;;;;;;;]xxxxx(\"; else std::cout << \")xxxxx[;;;;;;;;;>\";","title":"int getX()"},{"location":"wiki/window/#int-gety","text":"This function returns top coordinate of the window in pixels. It returns position of top corner of working area, without height of navigation bar. You can use getBarHeight to manually adjust coordinate to your needs. You can use Window.setPositionPixels or Window.setPositionCenter to set position of window using a code. Parameters This function doesn't have any parameters. Return value Return type is int . Return value is y pixel position of top left corner. Example This example sets console position to center if console is outside the screen. if (Window.getY() + Window.getHeight() > Window.getScreenHeight()) Window.setPositionCenter();","title":"int getY()"},{"location":"wiki/window/#int-getwidth","text":"This function returns width of the window in pixels. When calculating position of right corner of window use sum of Window.getX() and Window.getWidth() . Parameters This function doesn't have any parameters. Return value Return type is int . Return value is size in x of the window. Example This example sets the console size if console is too small. int size = Window.getScreenWidth() / 2; if (Window.getWidth() < size) Window.setSizePixels(size, Window.getScreenHeight()/2);","title":"int getWidth()"},{"location":"wiki/window/#int-getheight","text":"This function returns height of the window in pixels. When calculating position of bottom corner of window use sum of Window.getX() and Window.getHeight() . Parameters This function doesn't have any parameters. Return value Return type is int . Return value is size in y of the window. Example This example sets the screen size to match ratio of 16 : 9. int wh = Window.getHeight(); int ww = (16 * wh) / 9; Window.setSizePixels(ww, wh);","title":"int getHeight()"},{"location":"wiki/window/#int-getcolumns","text":"This function returns size of the window in columns. It is used when writing text to middle of the screen or to its corners. You can set window size in columns and rows using Window.setSizeChars() . Parameters This function doesn't have any parameters. Return value Return type is int . Return value is number of columns of the window. Example This example writes text in the middle of console width. std::string text = \"Start the application\"; int pos = Window.getColumns()/2 - text.length()/2 -1; Cursor.setPosition(pos, 0); std::cout << text;","title":"int getColumns()"},{"location":"wiki/window/#int-getrows","text":"This function returns size of the window in rows. It is used when writing text to middle of the screen or to its corners. You can set window size in columns and rows using Window.setSizeChars() . Parameters This function doesn't have any parameters. Return value Return type is int . Return value is number of rows of the window. Example This example writes a simple cross across the screen. int x = 0, rows = Window.getRows(), max = 2 * rows - 2; for(int y = 0; y < rows; y++) { Cursor.setPosition(x, y); std::cout << \"XXX\"; Cursor.setPosition(max - x, y); std::cout << \"XXX\"; x += 2; }","title":"int getRows()"},{"location":"wiki/window/#int-getscreenwidth","text":"This function returns width of the screen in pixels. If you want to set window position to center use Window.setPositionCenter() . Parameters This function doesn't have any parameters. Return value Return type is int . Return value is width of the screen in pixels. Example This example resizes the console size to the half of screen size. int screen_width = Window.getScreenWidth(); int screen_height = Window.getScreenHeight(); Window.setSizePixels(screen_width/2, screen_height/2);","title":"int getScreenWidth()"},{"location":"wiki/window/#int-getscreenheight","text":"This function returns height of the screen in pixels. It is the size of working area. You can use getBarHeight to add height of navigation bar. If you want to set window position to center use Window.setPositionCenter() . Parameters This function doesn't have any parameters. Return value Return type is int . Return value is height of the screen in pixels. Example This prints screen ratio. It uses greatest common devisor ( gcd ) from numberic, but you can write your own. #include <numeric> int width = Window.getScreenWidth(); int height = Window.getScreenHeight(); int greatest = std::gcd(width, height); std::cout << \"Your ratio is \" << width/greatest << \" : \" << height/greatest;","title":"int getScreenHeight()"},{"location":"wiki/window/#int-getbarheight","text":"This function returns height of the title bar in pixels. With this function you can determine if you are in fullscreen mode. If you want to make interactive application use Mouse.getX and Mouse.getY . Parameters This function doesn't have any parameters. Return value Return type is int . Return value is approximated height of the window title bar in pixels. Example This example asks user to hold Y key to set console to borderless mode. Then it writes a simple message. Keep in mind that the second if statement is not necessary in this small example and code can rewritten without it. std::cout << \"Hold Y to set window to borderless mode.\" << std::endl; Keyboard.waitUser(); if (Keyboard.get('Y')) Window.setFullscreenBorderless(); if (!Window.getBarHeight()) std::cout << \"You are in borderless fullscreen mode.\";","title":"int getBarHeight()"},{"location":"wiki/window/#wstring-gettitle","text":"This function gets the name of the console. The text is written in console header. Parameters This function doesn't have any parameters. Return value wstring wide string from standard library used as a constant. Example This example gets window title and writes it to screen using wcout. Cursor.setColor(WHITE); std::wcout << \"You are running from a \"; Cursor.setColor(LIGHTGRAY); std::wcout << Window.getTitle(); Cursor.setColor(WHITE); std::wcout << \" console.\";","title":"wstring getTitle()"},{"location":"wiki/window/#int-getdefaultcolorcolor-color","text":"This function get HEX value of default color from console palette. You need to specify which color you want to return. Parameters Color color from palette Return value Return type is int . Return value is numerical representation of color. You can print it using std::hex tag. Example This example prints rgb values of green color and hex value of black color. #include <iostream> #include <iomanip> #include \"swti/swti.hpp\" int main() { int green = Window.getDefaultColor(GREEN); int black = Window.getDefaultColor(BLACK); std::cout << \"Green in rgb is (\" << GET_RED(green) << \", \" << GET_GREEN(green) << \", \" << GET_BLUE(green) << \").\\n\"; std::cout << \"Black in hex is \" << std::setw(6) << std::setfill('0') << std::hex << black << \".\\n\"; return 0; }","title":"int getDefaultColor(Color color)"}]}